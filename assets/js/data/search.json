[ { "title": "023_探索 Podman 整合 Windows WSL2 的過程", "url": "/posts/Podman%E5%AE%89%E8%A3%9D%E5%9C%A8WSL2%E7%9A%84%E5%9D%91/", "categories": "DevOps", "tags": "system", "date": "2025-04-04 00:00:00 +0800", "snippet": "起源因為自己公司電腦開發環境的 container runtime 從 docker 移轉到 podman 了，所以家裡的桌機也想跟著轉，但公司是 Macbook，家裡桌機是 Windows + WSL2 的架構，因此有些設定差異滿大的，本篇目的在於紀錄一下 Podman 移轉的過程。參考資料 設定 Podman Socket bind WSL2 的過程 設定 WSL2完全未安裝 WSL2 和 podman desktop 用 “系統管理員” 開啟 powershell 執行 command 啟用 WSL2 重新啟動電腦 安裝 podman-desktop 按照步驟設定 podman-desktop 打開 powershell 使用 podman command 驗證安裝結果 目前筆者環境已有安裝 WSL2 所以此流程僅留存做紀錄已安裝 WSL2 但未安裝 podman desktop 下載 podman desktop 並按照步驟安裝完畢 進入 WSL2 的系統(以筆者為例為 ubuntu-24.04) 設定自動掛載 wsl2 目錄的設定 下載 podman-remote CLI 工具並放入 $PATH 設定 podman-remote 連線至 wsl2 下的 podman socket 測試 vscode devcontainer 可否成功使用 podman 啟用1. 下載 podman desktop 並按照步驟安裝完畢2~3. 進入 WSL2 系統，設定掛載 WSL2 目錄 為了要讓 podman 可以正常存取 WSL2 下的目錄，因為 WSL2 跟 windows 本身系統的目錄是分開的，但是 windows 系統和 WSL2 之間有一個神奇的目錄在 /mnt/wsl 這個地方可以讓兩邊的系統共同存取cat &lt;&lt;-EOF | sudo tee /etc/systemd/system/mnt-wsl-instances-${WSL_DISTRO_NAME}.mount[Unit]Description=WSL Instances[Mount]What=/Where=/mnt/wsl/instances/${WSL_DISTRO_NAME}Type=noneOptions=defaults,bind,X-mount.mkdir[Install]WantedBy=multi-user.targetEOFsudo systemctl daemon-reloadsudo systemctl enable --now mnt-wsl-instances-${WSL_DISTRO_NAME}.mount4. 下載 podman-remote CLIcd ~curl -OL https://github.com/containers/podman/releases/download/v5.4.2/podman-remote-static-linux_amd64.tar.gz tar xf podman-remote-static-linux_amd64.tar.gz sudo cp bin/podman-remote-static-linux_amd64 /usr/local/bin/rm -rf bin podman-remote-static-linux_amd64.tar.gz5. 設定 podman-remote 連線至 WSL2 的 podman socketpodman system connection add --default podman-machine-default-root unix:///mnt/wsl/podman-sockets/podman-machine-default/podman-root.socksudo usermod --append --groups 10 $(whoami)# logout &amp; loginpodman ps -a # verify podman commandpodman run --rm quay.io/podman/hello6. 設定 completionecho \"source &lt;(podman completion bash)\" &gt;&gt; ~/.bashrc# logout &amp; login7. 設定 vscode 使用 podman 作為 devcontainer 開發F1 -&gt; Open User Settings 目前 vscode devcontainer 的 podman 支援度很低，如果要在 WSL2 裡面用 devcontainer 的話，專案目錄要在 windows 的 c , d 槽下建立，不要在 WSL2 內的檔案系統放專案 相關討論的 Issue" }, { "title": "022_使用 AWS DMS 來移轉 RDS Aurora MySQL 資料庫進行 VPC Resource 無痛遷移", "url": "/posts/%E4%BD%BF%E7%94%A8AWS%E7%9A%84DMS%E7%A7%BB%E8%BD%89AuroraMySQL%E8%B3%87%E6%96%99%E5%BA%AB/", "categories": "Cloud", "tags": "aws", "date": "2024-12-24 00:00:00 +0800", "snippet": "起因舊有的 AWS 上，VPC 在不同的環境中會有 CIDR Overlay 的問題，為了改善當前架構並因應外部稽核，需要重新設計 VPC 及其網路規劃。目標 需要轉移現有 VPC 內所有資源 重新規範 VPC 內網路設定，其中包含 NACL、VPC Endpoint、Routing，Logging、Security Group 甚至是 Transit Gateway (多個 VPC Peering)工具 - AWS DMS DMS Fleet Advisor 可以用來收集 on-prem 資料和分析 server 的資料來構建移轉到 aws 的 inventory 和 schema 如果要 migrate 不同的 db engine 可以使用 DMS Schema Conversion。可以用 AWS 提供的 AWS Schema Conversion Tool (AWS SCT) 來轉換 local 的 Schema 當完成轉換條件後，可以透過 DMS 做一次性移轉或持續變更性的移轉來保持 source 和 target 的資料 sync AWS DMS replication process 概念圖執行 Migration Task 時 DMS 會做的 在傳統 Solution 裡面，遷移 DB 需要分析 hardware 和 software，針對其安裝及管理。但使用 AWS DMS 會自動做完這些評估，並進行遷移。 DMS 可以動態調整遷移的用量來符合實際的 workload，例如要增加額外的 disk space，只需要暫停遷移，調整後重新啟動遷移即可 DMS 是 pay-as-you-go，按量計費 DMS 自動管理所有執行 migration server 的 infra，包含 hardware/software/software patching 和 error reporting DMS 會自動 failover，如果主要的 replication server 發生任何原因而造成 failure，backup 的 replication server 會接手，只可能會造成一點或甚至 0 中斷。 DMS Fleet Advisor 自動管理 inventory 中的 data infra，它會生成 report 來協助評估遷移的計畫 DMS Schema Conversion 自動評估複雜的 source data provider，它也能轉換 database schema 和 code object 並格式化成 compatible 的 target database 可 applied 的內容 DMS 也可以協助更換最新的 DB Engine，有可能會比現在使用的更加 cost-effective DMS 支援現在最熱門的所有 DB Engine 作為 source，和廣泛的 target DMS 支援 heterogeneous 的 data migration (相異的 db engine 轉換) DMS 可以確保安全性，對於 data 可以用 KMS 加密，對於傳輸，DMS 提供 SSL 來加密。關於此次移轉的 Source And Target MySQL Source MySQL Target Homogeneous Migration NetworkingSource Endpoint (Database) - AWS RDS Aurora MySQL-8Source AWS RDS Aurora MySQL 調整 Maintenance &amp; Backup (AWS Console) Enable 自動備份 調整 ParameterGroup (AWS Console) binlog_format = ROW binlog_row_image = Full binlog_checksum = None log_slave_updates = TRUE wait_timeout = 1200 net_read_timeout = 1200 net_write_timeout = 1200 SQL 語句調整設定(MySQL Client Into DB) call mysql.rds_set_configuration('binlog retention hours', 24); Target Endpoint - AWS RDS Aurora MySQL-8Target AWS RDS Aurora MySQL 調整 Maintenance &amp; Backup (AWS Console) Enable 自動備份 調整 ParameterGroup wait_timeout = 1200 net_read_timeout = 1200 net_write_timeout = 1200 " }, { "title": "023_Github CI/CD", "url": "/posts/%E7%8E%A9%E8%BD%89GithubCICD/", "categories": "DevOps", "tags": "kubernetes", "date": "2024-11-26 00:00:00 +0800", "snippet": "起因因為公司 Github Org 的 CICD 日益漸增，加上目前組內討論想要把 CI/CD 的配置都統一管理到 Github Action，因此開始調研如何實作 ARC 有效利用測試區的 EKS 效能ARC 架構架構描述 安裝完畢後，AutoScalingRunnerSet Controller 呼叫 githun API 取得這個 runner scale set 屬於哪一個 runner group ID AutoScalingRunnerSet 在建立 Runner ScaleSet Listener 之前，呼叫 Github API 取得 Github Action 服務建立 runner scale set. Runner ScaleSet Listener 由 AutoScalingListener Controller 佈署，Runner ScaleSet Listener 會向 github action 建立連線並進行身份驗證，且開始監聽 當 Repo 發生 action event，github action 會分配獨立的 job 給 runner 或 runner scalesets，注意 runs-on 的 keyword 值需符合註冊 runner scaleset 的 label 當 Runner ScaleSet Listener 收到 Job Available，他會確定能不能 scale up 到描述的 desired count，如果可以，Runner ScaleSet Listener 會 acknowledges 這個 message Runner ScaleSet Listener 會透過 Kubernetes RBAC 發 HTTP Req 給 Kubernetes API Ephemeral RunnerSet 會嘗試創建 runner pods，如果 pods 創建失敗 controller 會嘗試最多 5 次在 24hr 內，若都無法成功，則 job 會被 cancel 當 runner pods 被創建成功，他會用 JIT (Just-In-Time) Token 去跟 Github Action 服務註冊並發出另外的 HTTP long poll connection 來接收要執行的 job details Github action 會分發 job 給註冊過的 runner pods 當 runner 把 job 執行完畢，EphemeralRunner Controller 檢查 Github Action 確認 runner 能不能 delete，如果可以 執行完畢，Ephemeral RunnerSet 刪除這個 runner安裝 主要分兩塊，一個是如何跟 Github 驗證，一個是如何讓 Kubernetes 能跟 Github Action 交互 authenticating action runner controller installationAuthenticating 進入組織設定頁面，進入 developer settings -&gt; Github App New 一個 Github App，這邊要取得一些驗證用的關鍵資訊 a. AppID b. Private Key .pem 格式 c. installation id 在 helm chart 裡面指定一個 kubernetes secret 定義 chart values YAML runnerScaleSetName: \"vivotek-arc\" # important , must to match workflow 'runs-on'githubConfigUrl: &lt;your-repository-url&gt;githubConfigSecret: pre-defined-secretminRunners: 0maxRunners: 5 helm install helm install --create-namespace -n arc-runners -f values.yaml &lt;runner-label&gt; ./ apply secret to arc-runners namespace kubectl apply -f pre-defined-secret.yaml 創建 secret 用於 runner 和 github 之間驗證apiVersion: v1kind: Secretmetadata: name: pre-defined-secret namespace: arc-runnerstype: Opaquedata: github_app_id: &lt;base64endcoded-app-id&gt; github_app_installation_id: &lt;base64encoded-installation-id&gt; github_app_private_key: &lt;base64endcoded-pem&gt;" }, { "title": "022_2024 KubeSummit", "url": "/posts/2024KubeSummit/", "categories": "Cloud", "tags": "kubernetes", "date": "2024-10-23 00:00:00 +0800", "snippet": "聆聽的議程Day1 10:00 ~ 10:30 10:50 ~ 11:20 11:40 ~ 12:20 13:20 - 14:00Day2 9:50 ~ 10:30 10:50 ~ 11:30 11:50 ~ 12:20 13:20 ~ 14:001 - 說明 GKE 跟 GKE 與 AI 一起應用的場景 Kubernetes + AI GPU 的寶貴資源可以無通攜帶至任何 Kubernetes 環境 最大化資源利用 GCP Kubernetes 使用 GPU Multi-instance GPUs Multi-Process Service GPU Time-Sharing Containr preloading 解決 AI 模型要載入到 GKE 的 Pod 時會需要耗費長時間初始化的問題 提早將 AI 模型掛載在 Node 上，讓 pod 啟動時提高初始化速度 搭配 GCS Fuse 將 Bucket 掛到 Pod Hyperdisk Ray 是一個 Python-based 的分散式運算的 framework https://www.ray.io/ GKE 有 Ray 的 add-on Batch job 的管理工具 Kueue 透過 DWS (Dynamic Workload Scheduler) 讓 GPU 不用提早準備好，也可以在要的時候不會有找不到 GPU Node 可用的情況 多租戶 Scaling fleet-based , multi-team , multi-cluster 管理 fleet dashboard 2 - Redhat KubeVirt 歷史演進 實體 -&gt; 虛擬 -&gt; 容器 現今則是 虛擬/容器被共同採用的策略為多數企業所選的方式 KubeVirt 在 kube 上跑 VM，想解決 container 沒有獨立自己的 OS 的問題 底層技術是 KVM Redhat 把這個 Project 整合進 OpenShift OpenShift Virtualization 強調 openshift 整盒社群 opensource 的功能整合起來做企業級的 support Openshift 跑的 Redhat enterprise linux 不用訂閱 (= =) OpenShift 提供 VM 線上移轉到 OpenShift 的技術 這邊提出不錯的概念 在 Cloud 上建立 Control plane，並用 KubeVirt 佈建 Datal plane Worker node 中心概念為：如何利用 Kubernetes 管理”所有的 virtualization” 工作負載 3 - 臺灣大型企業雲原生態勢與 GAI 衝擊 數位免疫系統 GitOps (Gartner) Gartner 技術雷達 Thoughtworks 技術雷達 RAG CloudEvents 工具類 Conan, Kaniko, Karpenter 新興技術雷達圖 切為四塊 , IT基礎架構, AP 架構與開發, Data 與 AI, 其他新興科技 政府學校新興技術 4 - 多租戶 K8s 管理實務：資源優化、實用技巧與升級策略 多 user 在 k8s 上使用 multi-tenant: 申請要用 k8s cluster 時，拿到的基礎單位會是 namespace 在 multi-tenant 要的是標準化，非客制化 multi-tenant 下的管理 node 管理 node scope 定位 用 node label/taint 來做管理手段 namespace 管理方式 naming 有個 prefix resource 管理 quota 設計，注意 resource request 設計會不會過高 用 admission webhook 來驗證 user 在使用上有沒有符合規範 管理 multi-tenant 用 operator + crd 來定義使用規範 cluster upgrade 會是 multi-tenant 的一個大挑戰 Day25- 雲端節費 20% 策略：利用 100% Spot Kubernetes 打造低成本、高可靠應用架構 趨勢會是 GenAI 產業雲端平台 industry cloud platform 三位一體, 基本上不可能三種都成立 高可用 維運人力 成本 spot 可以用在 dev / staging6 - 104 在 GitOps 大規模實踐中的甜蜜與苦澀 gitops 的 repo 可以採用康威定律 一個 team 一個 gitops repo multi-tenant 人工 &gt; 30min 容易出錯 規模化管理重點 需要有模板，簡化 default value 的設定 大部分各 team 的技術棧會相當類似，所以就可以知道 value 大概長怎樣 採用 gitops 可以讓大家都看得到，也可以保存歷史紀錄，在特定的場合下可以作為一個一起 review 的契機 7 - Cloud Native Chronicles: A decade of innovation 探討 sustainability keda carbon kepler 可以 export 碳排量, 用電等相關的 prom metrics ebpf 8 - 旅遊不便險應用 - EKS 架構設計與聯盟鏈應用實踐 EKS 區塊鏈專案架構 IRSA Integration QA IAM policy 管理 未來在 Kubernetes 發展越來越成熟之後，透過 module，各式各樣的 controller , operator , 我們有機會降低管理 application pod 的 irsa 所產生的 effort 當 cross cluster 的 pod 交互時，有方法可以知道來源跟目的嗎 提問者原本是採用 vpce 的方式，但這方式會不知道目標，想知道有沒有好的做法 講者認為，可以採用在 header 塞 source/destination 的方式 cluster public accessible 要如何因應稽核改為 private endpoint 會透過 session manager 管理，不再使用 local 管理 會讓 runner 去執行，而不是直接修改 稽核面可以提出有看 cloudtrail , api logs，提出有針對安全疑慮的監控 " }, { "title": "021_玩玩 ECS 的監控機制", "url": "/posts/%E7%8E%A9%E7%8E%A9ECS%E7%9A%84%E7%9B%A3%E6%8E%A7%E6%A9%9F%E5%88%B6/", "categories": "Cloud", "tags": "aws", "date": "2024-09-24 00:00:00 +0800", "snippet": "目標因為工作需求，需要在 ECS Fargate 上實作 coturn server 並保留原本 auto-scaling 的機制，但礙於原本是用 EC2 服務做的，彈性很大，scaling 參考的 metric 是 networkIn，這讓移轉到 ECS Fargate 的可行性變得稍微複雜關於 ECS Auto-Scaling 的說明 https://docs.aws.amazon.com/zh_tw/AmazonECS/latest/developerguide/service-auto-scaling.html 支援三種 type 的 auto-scaling https://docs.aws.amazon.com/zh_tw/autoscaling/application/userguide/monitoring-cloudwatch.html#predefined-metrics 目前 Predefined 的 metrics 只有三個 CPUUtilization / MemoryUtilization / RequestCountPerTarget https://docs.aws.amazon.com/zh_tw/AmazonECS/latest/developerguide/cloudwatch-container-insights.html 如果要有其他 metric 要啟用 ContainerInsight，會額外收費 " }, { "title": "020_Java 課程 Day12", "url": "/posts/Java%E8%AA%B2%E7%A8%8BDay12/", "categories": "Course", "tags": "java", "date": "2022-09-25 09:30:00 +0800", "snippet": "今日進度 探討 multi-thread synchornized 案例 multi-thread 的 wait() , notify() , notifyAll()，Thread 的 Communication Q: 為什麼 Java 是天生的 multi-thread A1: 因為 Object 本身就有 wait() 和 notify 方法可以呼叫 A2: 因為 main 方法本身就是一個 thread Deadlock Java8 補充synchornized - 存款案例 多執行緒下操作同一資料，造成資料不一致的結果而讓結果不符預期Thread Communication - 生產者與消費者案例 延伸上例，生產過剩及消費過剩的現象，但透過 thread communication 可以有效預防資料不一致問題Deadlock - 筷子與人的案例 避免死結最好是預防而非偵測它。最簡單的方式是將一群物件的鎖定動作，依據相同的順序執行。Java8 補充 Java8 最大的更新功能是 Stream API -&gt; java.util.stream package Stream 專門用來處理 Collection，Java8 的 Stream 搭配 lambda expression 讓 Collection 的操作更加便利 推導 Lambda Expression Method Reference -&gt; 這邊有用 forEach() 方法推導一次 method reference 語法糖的流程 這邊有個很重要的地方，forEach() 方法傳入的型別是 ConsumerStream 特性 input -&gt; 中間操作(過濾條件) -&gt; output Java8 四大函數式介面 =&gt; Consumer / Supplier / Function / Predicate Java 的 Stream API，主要涵蓋 3 大部分 定義 Stream 來源 (一個 Stream 物件) 中介操作 (類似定義過濾條件，必定回傳 Stream 物件) 終端操作 (將 Stream 物件轉換為想要的 output) stream API 中對應 functional interface 的 map() 方法 -&gt; Function 介面 filter() 方法 -&gt; Predicate 介面其他常用 method sorted() 方法 limit() 方法 collect() 方法" }, { "title": "019_Java 課程 Day11", "url": "/posts/Java%E8%AA%B2%E7%A8%8BDay11/", "categories": "Course", "tags": "java", "date": "2022-09-24 09:30:00 +0800", "snippet": "今日進度 InputStreamReader 與 OutputStreamReader byte 與 char 互轉的關鍵 class BufferedInputStream readLine() 方法 IO 三大關鍵要素 in 怎接 in , out 怎接 out in , out 的轉換 byte 轉 char IO 進階 =&gt; 物件序列化 Multi-Thread物件序列化與反序列化 奠定分散式運算的基礎前言 如果物件要做序列化，必定要 implements Serializable 介面 Java 有 80% 以上的類別都有實作 Serializable 介面 宣告為 transient 和 static 的成員不會被序列化ObjectInputStream 與 ObjectOutputStream ObjectOutputStream 的 writeObject 方法，把物件寫出 ObjectInputStream 的 readObject 方法，把物件讀入多執行緒 Multi-Thread 條件: 要繼承 Thread 類別 or 實作 Runnable 介面 Runnable 介面只有一個 run() 方法，且實作 Runnable 介面最終還是要傳入 Thread 建構元透過呼叫 Thread 的 start() 方法來執行 呼叫 start() 方法是把 thread 放進去 cpu 排程，而如果改成呼叫 run() 方法，就變成不是多執行緒了，會變回單執行緒。 如果一台 computer 只有 single core，那麼 multi-thread 或許可能比 single-thread 更慢，multi-thread 會快過 single-thread 是因為現在的 cpu 基本都超過 single core多工種類 合作型 分享 cpu 是 process 的責任，容易造成獨佔 強制型 (windows 作業系統屬於這種) 由系統分配(排程schedule)，cpu 的使用無法獨佔 參考 https://www.geeksforgeeks.org/difference-between-preemptive-and-cooperative-multitasking/ thread 的六個狀態 NEWA thread that has not yet started is in this state. RUNNABLEA thread executing in the Java virtual machine is in this state. BLOCKEDA thread that is blocked waiting for a monitor lock is in this state. WAITINGA thread that is waiting indefinitely for another thread to perform a particular action is in this state. TIMED_WAITINGA thread that is waiting for another thread to perform an action for up to a specified waiting time is in this state. TERMINATEDA thread that has exited is in this state. 參考 https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Thread.State.htmlThread 重要方法 setName() static 的方法 currentThread() -&gt; 回傳當前 thread 的物件Thread 的 Priority在 Multi-Thread 裡面，優先權之於執行順序並不是絕對。這意味著，在 Multi-Thread 不要用優先權來想要控制程式的執行。 預設的 thread 優先權是 5，而優先權的權重是介於 1~10 之間的數字。參考 https://docs.oracle.com/en/java/javase/17/docs/api/constant-values.html#java.lang.Thread.MAX_PRIORITY相關 method getPriority() setPriority()Thread 的控制方式 join() 方法，呼叫 (等待對象).join() 。它會讓當前 thread 等待該呼叫執行結束才繼續 yield() 方法，這邊的程式碼把 computer 切成 single core 的再去測試會比較明顯Synchronized 關鍵字 在宣告 method 時加上 Synchronized 在 method body 內加上 Synchronized block// 第一種public void Synchronized method1() { //Todo...}// 第二種public void Synchronized method2() { // Todo Section 1 without sync Synchronized(this) { // Todo critical section }}" }, { "title": "018_Java 課程 Day10", "url": "/posts/Java%E8%AA%B2%E7%A8%8BDay10/", "categories": "Course", "tags": "java", "date": "2022-09-18 09:30:00 +0800", "snippet": "今日進度 File 類別 IO Stream 和 Reader 與 Writer關於 File 類別 File 建構子 getName() 方法 delete() 方法 renameTo() 方法 mkdirs() 方法RandomAccessFile 類別此類別的 read() 和 write() 方法來延伸其它 io 類別的概念關於 InputStream 與 OutputStream 抽象類別 這個系列的 read() 和 write() 方法都跟 RandomAccessFile 老類別的 read() 和 write() 方法概念相同 因此透過 RandomAccessFile 類別得 read() 和 write() 方法可以練習其功能和觀察差異關於 Reader 與 Writer 抽象類別 與 InputStream 和 OutputStream 差異在 unicode 的處理 read() 和 write() 方法也有，概念也是跟 RandomAccessFile 類別的方法概念一樣 雖然 Reader 和 Writer 看起來好用，但是它們是基於 char 的，也就是字元，而在網路IO或裝置IO的資料都是基於 byte 的，所以 IO Stream 更重要也更基礎輸入輸出的 read() 和 write() 方法的概念官方說明，read() 是 Reads a byte of data from this file. 這意味著只讀取一個 byte，這種做法不常見，因為檔案一大這樣讀取的速度會非常緩慢。 非常重要：在 IntputStream 系列裡面，Java 9 新增了 readAllBytes() 方法，他能夠完整精準地抓到 input 的所有資料讀近來變成 byte[] 變成最好用的方法IO 三個課題 input 和 output 如何定義使用 將資料在 input 和 output 資料介接，也就是把 input 資料讀入記憶體，再把記憶體的資料 output 到想要的目的地（如檔案讀取，終端輸出） 在 input 和 output 之間做資料處理，如編碼轉換、插入資料" }, { "title": "017_Java 課程 Day9", "url": "/posts/Java%E8%AA%B2%E7%A8%8BDay9/", "categories": "Course", "tags": "java", "date": "2022-09-17 09:30:00 +0800", "snippet": "今日進度 Collection 總整理 Comparable 介面 泛型，Generic Auto-boxing 與 Auto-unboxing 複習 學習 for-eachCollection整理不同的 Collection 特性相似特性Tree 系列的 Class 特性為依大小排序Linked 系列的 Class 特性為依 add() 順序排序SetHashSet - 快，會亂放TreeSet - 依大小排序，較慢LinkedHashSet - 依 add() 順序排序，較慢List 只要記得 List 都是要依 add() 順序排序，如果要大小，要用 Collections.sort 方法ArrayList - 從最後面 add() element 會快一點Vector - thread-safeLinkedList - 如果有 add() 和 remove() element 需求，用這個快一點MapHashTable - thread-safeHashMap - 快，較慢TreeMap - 依大小排序，較慢LinkedHashMap - 依 add() 順序排序關於 Collection 的 iterator在 Java1.5 之後，iterable 介面出現，讓 for-each 功能出現把 code 變得更簡單。 這邊有個理解順序，iterable 介面是被 collection 介面繼承，而很多 Collection 相關的 class 都有 implements Collection 介面聊聊 Sort 功能在排序的時後，必須有兩個規定 要相同資料型態 要實作 comparable延伸所以在使用 TreeSet 和 TreeMap 的時候，裡面的物件必須要相同 data type 並且要實作 comparable 才可以放(作比較)。延伸思考，策略模式當發現沒有實作 Comparable 的話，可以額外實作一個 Comparator 傳入 sort() 方法，讓其可以排序，所以可以看到 sort() 方法有 Overload 參考 collections 類別的 sort 方法 https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Collections.htmlforeach跟泛型搭配才可發揮出效用，因為透過泛型我們可以讓 Collection 有型別約束，並且透過 foreach 宣告我們可以知道撈出的資料型別，因此就可以直接宣告來用List&lt;String&gt; myList = new ArrayList&lt;String&gt;();" }, { "title": "016_Java 課程 Day8", "url": "/posts/Java%E8%AA%B2%E7%A8%8BDay8/", "categories": "Course", "tags": "java", "date": "2022-09-04 09:30:00 +0800", "snippet": "今日進度 String、Stringbuffer 與 StringBuilder String 是不可變，StringBuffer 和 StringBuilder 是不可變 StringBuffer 是 thread-safe 但 StringBuilder 不是 StringBuffer 從 JDK 1.0 就有，而 StringBuilder 是官方在 JDK1.5後針對不需要考慮多執行緒同步問題的環境所設計，其 method 與 StringBuffer 完全相同 StringBuffer 對記憶體使用起來較 String 乾淨(場景：爬蟲下來的字串處理，若同一段字串在處理，基本上用 StringBuffer 記憶體會比較乾淨) StringTokenizer 用來切割字串，預設情況用 \" \" 空格做分割符號 日期類別 java.util.Calendar 設定某一特定日期很好用 java.util.Date 在 Java 1.1 開始後有很大部分功能都被淘汰，但是最重要的是還有一個 getTime() 方法 java.sql.Date 為 java.util.Date 的子類別，用來處理資料庫格式的日期 Inner Class 內部類別 Inner class 或稱為 nested class 成員內部類別與匿名內部類別 匿名內部類別(和 lambda 有關) Collections 集合很亂很雜因為歷史從 1.0 1.2 1.5 1.8 都有更新，其中 Vector 和 HashTable 是最老的 Class 在 Collection 介面的子介面都有 iterator() 方法，會返回一個 Iteractor 介面 String 與 StringBufferpublic class TestStringBuffer { public static void main(String[] args) { // 查看 Stringbuffer sb1 和 sb2 的變化 StringBuffer sb1 = new StringBuffer(\"AB\"); System.out.println(\"sb1 = \" + sb1); StringBuffer sb2 = sb1.append(\"CD\"); System.out.println(\"sb1 = \" + sb1); System.out.println(\"sb2 = \" + sb2); System.out.println(sb1==sb2); System.out.println(sb1.equals(sb2)); // 分隔線 System.out.println(\"==========\"); // 改成 String 與 StringBuffer 做比較 String s1 = new String(\"AB\"); System.out.println(\"s1 =\" + s1); String s2 = s1 + \"CD\"; System.out.println(\"s1 = \" + s1); System.out.println(\"s2 = \" + s2); System.out.println(s1==s2); System.out.println(s1.equals(s2)); }} 補充強調：在原始(沒有 override)的情況下，class 的 .equals method 就是 == 的概念，是比對記憶體日期相關在日期轉換有一個重點，只要能拿到毫秒數，就能夠轉換成想要的各種時間。毫秒數指的是 number of milliseconds since January 1, 1970, 00:00:00 GMT。在 API 文件中 java.util.Date Class 裡面的 getTime 方法有提到Inner Class 內部類別主要分四種 靜態內部類別 成員內部類別 區域內部類別 匿名內部類別 其中 匿名內部類別 最重要匿名類別經常用在抽象類別，或者介面的抽象方法實作在開始說匿名內部類別之前，先來看看 interface 的一個操作interface Display2 {\tint num1 = 100; \tint num2 = 10;\tvoid disp2();}class TestInterface2 {\t\tpublic static void main(String args[]) { // 這邊會發現不能 new，編譯就會錯了 Display2 p1 = new Display2(); // 這邊發現只要加入 {} 並實作方法，就可以 new 了\t\tDisplay2 p2 = new Display2(){ // public 要加，因為在 interface 裡面定義的 method 都隱性帶有 public abstract \t\t\tpublic void disp2() { \t\t System.out.print(num1 + \" + \" + num2 + \" = \");\t\t System.out.println(num1 + num2);\t }\t\t}; // 這個分號就是從上面那個 new 展開來的\t\tp2.disp2();\t}}Collections 介面 Collections 介面最重要的兩個子介面 Set 和 Listiterator 方法所有 Collection 介面的子類別都有該方法，而使用該方法後會返回一個 Interator 介面。並且可以透過這個返回取得該 Collections 的 element 所以 interactor 是一個取 element 的關鍵 methodSet 介面 Element 不可重複，且沒有順序HashSetSet set = new HashSet();List 介面ArrayList Element 可重複，有順序性。這邊的順序指的是加入 element 的順序(不是依大小) 若只新增 element，不考慮其他情況，則 ArrayList 效率會好一點 List list = new ArrayList(); Vector 跟 ArrayList 很像，但 Vector 的重點在於 thread-safe Vector 與 ArrayList 的比較，LinkedList與 ArrayList 很像，差異在若 element 會一直插入、刪除，用 LinkedList 效率會較好補充 Enumeration雖然 Java SE 不會再用，但 Java EE 部分的程式碼會用到，因此需要知道此 Enumeration 和 Iterator 的差異及歷史Map 介面Hashtable key/value 資料格式，key 是 Object 型別，value 也是 Object 型別 從 JDK 1.2 的 Map 介面出現，Hashtable 加入 Map 介面才實作 Map 介面的方法 與 HashMap 很像但 Hashtable 的重點在於 thread-safe 迴圈會用 keySet()，它會返回整個 map 的 key" }, { "title": "015_Java 課程 Day7", "url": "/posts/Java%E8%AA%B2%E7%A8%8BDay7/", "categories": "Course", "tags": "java", "date": "2022-09-03 09:30:00 +0800", "snippet": "今日進度 空介面 看到空介面要先觀察實作這個空介面有什麼優點 Java 中最著名的兩個空介面，一個是 cloneable 一個是 Serializable，其中 Serializable 大約 Java 90% 的 class 都會實作，非常重要 說明所有 class 都會繼承的 object 類別 說明 object 類別的 11 個方法 boxing / unboxing / auto-boxing / auto-unboxing 基本資料型別與包裝類別互轉的時候會使用 較重要的 method valueOf 用來將字串轉成 Numbers 因為在 server 之間傳輸都是字串型別，不會有其他型別。因此在字串的處理、轉換就相當重要 錯誤處理 Exceptions 和 Assertions，大部分都是 Exceptions，Assertions 較少用 JDK1.4 出了一個 AssertionsError 至少讓 error 前可以稍微處理一下，但仍不常使用 Runtime Exceptions 比較特別，它允許在編譯時期可以先不寫 try-catch 但像是 IOExceptions 和 SQLExceptions 就強迫在寫的時候一定要寫 try-catch空介面 Cloneable 與 Serializable Cloneable 較少用，在 Java 中的 class 要有 implements Cloneable interface 才可以做物件複製 Serializable 很重要，在 Java 中 90% 的 class 都有 implements Serializable interfaceSerializable主要用於序列化存儲資料，將 class 轉成 16 進制的檔案，讓該 class 可以傳送給他人(其他伺服器)使用Cloneable 範例 - 會拋出 CloneNotSupportedExceptionpublic class CloneableShirt implements Cloneable { private char colorCode = 'U'; public char getColorCode() { return colorCode; } public void setColorCode(char newCode) { switch (newCode) { case 'R': case 'G': case 'B': colorCode = newCode; break; default: System.out.println(\"請輸入 R, G, or B\"); } } public static void main(String[] args) { CloneableShirt myShirt = new CloneableShirt(); CloneableShirt yourShirt = new CloneableShirt(); myShirt.setColorCode('R'); yourShirt.setColorCode('G'); System.out.println(myShirt.getColorCode()); //R try { myShirt = (CloneableShirt)yourShirt.clone(); }catch (CloneNotSupportedException e) { System.out.println(\"不允許複製此物件!!\"); e.printStackTrace(); } System.out.println(myShirt.getColorCode()); //G }} 要用 .clone() method 必定要 implements Cloneable interfaceObject 類別finalizetoString 與 getClass在常用的 System.out.println 中，就會自動調用 toString() 方法了hashCode 和 equals錯誤處理 Exceptions 和 Assertions最重要的 Java 錯誤模型 Error 通常就是災難性的錯誤，是無解的，必須修復錯誤要小的範圍先捕捉，大的在後面捕捉，否則編譯就錯了public class DemoExceptions { public static void main(String[] args) { String[] arr = {\"Hello0\",\"Hello1\",\"Hello2\"}; int i = 0; While(i &lt; 4) { try { System.out.println(arr[i]); } catch (ArrayIndexOutOfBoundsException e) { System.out.println(\"小範圍的寫前面\"); } catch (Exception e) { System.out.println(\"大範圍的寫後面\"); } } }}finally 必須執行的 sectionpublic class DemoExceptions { public static void main(String[] args) { String[] arr = {\"Hello0\",\"Hello1\",\"Hello2\"}; int i = 0; While(i &lt; 4) { try { System.out.println(arr[i]); } catch (ArrayIndexOutOfBoundsException e) { System.out.println(\"小範圍的寫前面\"); } catch (Exception e) { System.out.println(\"大範圍的寫後面\"); } finally { System.out.println(\"必須執行的 code\"); } } }} 常用來釋放有限資源，例如 database connectionthrows 在定義 method 時使用在宣告 method 時，可以透過 throws 拋出 Exceptions 給呼叫該 method 的人(method)去處理。而如果是 checked exceptions 則處理方法有兩種 把 method 裡面呼叫該 method 的 section 加 try-catch 或是在該定義該 method 時再寫 throws 拋出給更上層呼叫該 method 的人(method)處理第一種處理方式public class Test3_throws { String[] strs = {\"Hello0\", \"Hello1\", \"Hello2\"}; public void printStrs(int i) throws Exception { System.out.println(strs[i]); } public static void main(String[] args) { int i = 0; Test3_throws t3 = new Test3_throws(); while(i &lt; 4) { try { t3.printStrs(i); } catch (ArrayIndexOutOfBoundsException e) { System.out.println(\"1-例外\"); } catch (Exception e) { System.out.println(\"2-例外\"); } i++; } }}第二種處理方式 - main 方法拋出 exceptionspublic class Test4_throws { String[] strs = {\"Hello0\", \"Hello1\", \"Hello2\"}; public void printStrs(int i) throws Exception { System.out.println(strs[i]); } public static void main(String[] args) throws Exception { int i = 0; Test4_throws t4 = new Test4_throws(); while(i &lt; 4) { t4.printStrs(i); i++; } }}throw在 method 內拋出錯誤，這邊要注意 throws 是宣告 method 的地方，而 throw 是在 method 內。兩個常用的 exceptions object method getMessage() printStackTrace() throw 丟出的物件要繼承 Throwable 才可以被 throwpublic class Test5_ThrowDemo {\tpublic static double method(double i, double j) throws ArithmeticException {\t\tdouble result;\t\tif (j == 0) {\t\t\tthrow new ArithmeticException(\"除到0，算數錯誤~!\");\t\t}\t\tresult = i / j;\t\treturn result;\t}\tpublic static void main(String[] args) {\t\ttry {\t\t\tSystem.out.println(method(1, 0));\t\t} catch (ArithmeticException e) {\t\t\tSystem.out.println(e.getMessage());\t\t\t//或\t\t\te.printStackTrace();\t\t}\t}}Assertion使用 Assert 的條件是加入 Assert 不應該影響整個邏輯、流程，Assert 僅用在測試、壓力測試等等情境。官網舉例主要有四個情況 Control flow invariants (流程的不變性) Internal invariants (內部流程執行的不變性) 私有函數結果的檢查 程式運行中的一致性" }, { "title": "014_Java 多線程筆記", "url": "/posts/Java%E5%A4%9A%E7%B7%9A%E7%A8%8B%E7%AD%86%E8%A8%98/", "categories": "Backend", "tags": "java", "date": "2022-09-01 20:15:00 +0800", "snippet": "目標練習在 Java 中實現多線程的寫法，以及透過多線程方式時作一些小功能進行測試Java 中實現多線程的方式1. 透過繼承 Thread Class創建一個 class 並繼承 Thread class 後，要 Override run() 方法。而透過 class 創建 instance 之後，透過 start() 方法執行public class Person extends Thread { @Override public void run() { // 要覆寫 run 方法 }}特性因為 Java 只有單一繼承，所以會受到侷限，如果一個 class 已經繼承 Thread class 將不能在繼承其他 class2. 透過實作 Runnable interface創建一個 class 並 implements Runnable interface，一樣要 Override run() 方法。透過 new Thread() 傳入實作 Runnable 的 instance 並調用 start() 方法執行public class Person implements Runnable { @Override public void run() { // 要覆寫 run 方法 }}特性推薦使用，使用上較靈活3. 實作 Callable interface特性透過 class 實作 callable interface，並且會有返回值。執行的步驟必須先創建 ExecutorService 宣告有多少線程在 Thread Pool 裡面，再透過 Future 來接住返回值，並在執行完關閉 ExecutorService。較 1、2 比較大的差異是可以定義 return value 可以拋出 exception。併發問題當多線程對單一資源進行操作，會出現資源衝突導致資料混亂的問題案例 - 搶票情境假設有 10 張票，四個 thread 同時買票會發生甚麼事範例public class TicketBuy implements Runnable{ private int ticketNums = 10; @Override public void run() { for (int i = 0; i &lt; ticketNums; i++) { System.out.println(Thread.currentThread().getName() + \"搶到了\" + i + \"的票\"); } } public static void main(String[] args) { // Create instance TicketBuy t = new TicketBuy(); // 多線程執行 new Thread(t,\"t1\").start(); new Thread(t,\"t2\").start(); new Thread(t,\"t3\").start(); new Thread(t,\"t4\").start(); }}結果圖 會出現票有重複搶的情況龜兔賽跑案例需求 創建一個賽道，走一百步的長度會到終點 判斷比賽是否結束 要印出勝利者 因為龜兔賽跑中兔子會休息，因此模擬兔子休息 龜兔賽跑中最後是由烏龜獲勝範例public class Race implements Runnable{ private static String winner; @Override public void run() { // 一百步的賽道 for (int i = 1; i &lt;= 100; i++) { // 模擬兔子休息 if (Thread.currentThread().getName().equals(\"兔子\") &amp;&amp; i%10==0) { try { Thread.sleep(5); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } } // 調用 gameOver 方法判斷比賽是否結束 boolean result = gameOver(i); if (result) { break; } // 執行跑步 System.out.println(Thread.currentThread().getName() + \"跑了\" + i + \"步\"); } } // 傳入走的步數 private boolean gameOver(int steps) { // 如果 winner 不為空返回 true，如果 steps == 100 返回 true，其他結果返回 false if (winner != null) { return true; } { if (steps == 100) { winner = Thread.currentThread().getName(); System.out.println(\"優勝者: \" + winner); return true; } } return false; } // 主程式，開啟兩條線程模擬 100 步跑道比賽，一個為兔子，一個為烏龜 public static void main(String[] args) { Race race = new Race(); new Thread(race, \"兔子\").start(); new Thread(race, \"烏龜\").start(); } }關於 lambda 當一個 interface 只有一個 method 那就是 functional interface lambda 可以避免過度寫 inner class 簡化程式碼Thread 狀態 初始狀態 就緒狀態(還沒被調度) 運行狀態 阻塞狀態(調用 sleep 或 wait 等，當 thread 被鎖定時的狀態) 結束(死亡狀態，thread 運行結束)Thread 種類 user thread daemon threadThread 的 method setPriority 更改 thread 優先權 sleep 讓當前正在執行的 thread 休眠 (單位 - 毫秒) join 等待該 thread 結束 (插隊效果) yield 暫停該 thread 並執行其他 thread (不一定會成功，要看 cpu 調度) interrupt 中斷 thread isAlive 檢查 thread 是否處於 active 狀態 getState 檢查狀態 (Thread 有五種狀態是用 enum 宣告的) setDaemon[預設是 false] (守護 thread 的特性) - JVM 不會等 daemon thread 執行結束只要 user thread 結束就會結束了sleep 方法 - 放大問題的顯現 用來讓 thread 進入等待狀態setPriority 方法 最高的優先級值為 10 main 方法是預設的優先級值為 5 沒有設定優先級的 thread 也一樣是預設值 5 優先級值的範圍是 1 ~ 10 優先高不代表先被執行，它代表的僅是被調度的機率高 優先級高不代表會先被執行，設定優先級是調整 CPU 調度 thread 的機率而已Thread 同步 重點部分當 multi thread 同時 access 一個 object(resource 時) 就要處理 thread 同步的問題，而 thread 同步其實就是一種等待機制(排隊)隊列與鎖一個 object 都會有鎖，而要解決 thread 不安全問題就要透過隊列+鎖thread 同步問題點探討 一個 thread 拿著鎖，其它要用該鎖的 thread 就會等待 在多 thread 共同競爭下，加鎖和釋放鎖會導致 context switch 和調度延遲進而造成效能下降 一個優先級高的 thread 若因為一個優先級低的 thread 拿著鎖而必須等待，就會造成執行順序顛倒(混亂)進而影響效能 關鍵在 thread 同步的情況必然是一個 安全和效能的取捨asynchornized 關鍵字 可以用在 method 上，也可以直接聲明一個 synchornized code block 在 block 上針對需要隊列鎖處理的 Object(或者說資源)，例如語法deadlock 當一個 thread 持有一個物件的鎖還想拿另一個物件的鎖就容易造成 deadlock情境灰姑娘與白雪公主都想要化妝，化妝會用到口紅及鏡子物件。在一個時間點，灰姑娘拿了口紅，白雪公主拿了鏡子，此時灰姑娘還想要拿鏡子，白學公主也想拿口紅，兩個人就僵持不下。就造成了 deadlock// 口紅class Lipstick { }// 鏡子class Mirror {}public class Mackup extends Thread { private int choice; private String name; static Lipstick g1 = new Lipstick(); static Mirror g2 = new Mirror(); // 建構子 public Mackup(int choice , String name) { this.choice = choice; this.name = name; } @Override public void run() { doMakeup(); } public void doMakeup(){ if(choice == 0) { synchronized(g1) { System.out.println(name + \"拿到了口紅\"); synchronized(g2) { System.out.println(name + \"拿到了鏡子\"); } } System.out.println(name + \"開始化妝\"); } else { synchronized(g2) { System.out.println(name + \"拿到了鏡子\"); synchronized(g1) { System.out.println(name + \"拿到了口紅\"); } } System.out.println(name + \"開始化妝\"); } } public static void main(String[] args) { Mackup role1 = new Mackup(0, \"灰姑娘\"); Mackup role2 = new Mackup(1, \"白雪公主\"); role1.start(); role2.start(); // 會發現永遠沒人可以開始化妝 }}" }, { "title": "013_Java 課程 Day6", "url": "/posts/Java%E8%AA%B2%E7%A8%8BDay6/", "categories": "Course", "tags": "java", "date": "2022-08-28 09:30:00 +0800", "snippet": "今日進度 套件(package)、import 與 classpath 為啥有時候要使用全路徑宣告，例如 java.util.Date mydate = new java.util.Date(); 因為有可能有兩個套件有相同 class 名稱，例如 java.util 和 java.sql 裡面都有 Date 類別 java 如果用 * import 並不會影響效能，C++ 才會，因為 java 是用到才去找那個 class 為啥有時候會看到 import 不直接用 *，而是個別 import 因為若要讓新同仁快速了解在使用的 class 來自哪裡，這樣可以不會造成同仁要從一整個 package 去查全部的 class java 9 以前有定義 core lib 和 extension lib 的配置 java 在配置 classpath 的時候路徑有含 /* 才包含 .jar 檔，否則就只包含 .class 而已 例如宣告 classpath = \".;C:/myClass/;C:/myLib/*\"，可以看到有另外兩個目錄 C:/myClass/ 代表會包含該目錄下所有的 .class 檔案 C:/myLib/* 代表包含該目錄下所有 .jar 檔案 說明 java -cp 指令 javac -classpath 和 java -classpath 存取修飾詞 protected 基本上都用在 Java EE 為了資安，Java SE 基本上用不到 提供讓 same package 的所有 class or method 存取，也提供給任何其他 package 的 subclass 存取 但 protected 不提供給其它 package 的 class 存取，其它 package 要是 subclass 才可以(也就是要繼承後才可以存取) final 關鍵字 用在 class 代表該 class 不能被繼承 用在 method 代表該 method 不能被 override 用在 variables 代表該 variables 的值不能在被修改 用在 object reference variables 代表不能再被指向到另一個 memory address 值 關於 static 區塊 static {} static 變數 + static 方法 + 建構子示範一個工廠製造物件流水號的範例 static 區塊會在類別載入的時候執行一次，意味著它會比 main 方法更早執行 static 區塊用來撰寫類別在載入時要執行一次的動作 這邊的 static 區塊的範例說明，一開始所初始化後，工廠所製造的物件數量要由工廠的 class 控制 abstract 抽象修飾詞 - 要搭配多型才有意義 定義規格給子類別 保證讓多型可以借得到(父類別 method)，下得來(子類別有 override) 讓錯誤發生在編譯時期 抽象 abstract 關鍵字在多型來說非常重要 interface 介面 - interface 在定義 method 時，可以不用 + public abstract (當然也可以加) 基本上抽象類別的功能它都有，唯一不同的是介面的 method 必須都是抽象方法 在 interface 內的 variables 和 object reference variables 都會自動賦予 public static final 在 interface 內的 method 都會自動加上 public abstract 介面三大目的，1.多重繼承、2.定義規格、3.貼標籤，轉型，降低相依性 要練習 Car interface 的範例 因為上面的特性，當 class 在 implements 一個 interface 的時候，實作的方法要記得宣告成 public" }, { "title": "012_Java 課程 Day5", "url": "/posts/Java%E8%AA%B2%E7%A8%8BDay5/", "categories": "Course", "tags": "java", "date": "2022-08-27 09:30:00 +0800", "snippet": "今日進度 Java 的 pass in value 與 pass in reference 原始資料型別做為參數傳入 method 修改後再打印的情況 物件型別做為參數傳入 method 修改後再打印的情況 Java 套件的 import 有三種方法 引入整個套件 import java.util.*; 引入套件裡面的 class import java.util.Arrays; 不引入，但直接呼叫套件全部名稱 java.util.Arrays.sort Java 繼承 Java 只能單一繼承 Java 用 interface 實現多重繼承的功能 Java 的所有 Class 都會繼承 java.lang.Object 類別 Overriding 概念 存取控制修飾詞在 Overriding 的使用限制 throw Exception 在 Overriding 的使用限制 Super 關鍵字 提到無窮呼叫方法造成 stackoverflow error 的情況 比較封裝過後用 super 呼叫，和沒封裝的情況。這邊強調 提高程式碼一致性 這邊如果透過封裝和 super 來呼叫父類別的方法，可以有效的控管子類別的寫法。也能提高程式碼重複可用性 多型 多型宣告，左邊使用上層類別，= 號右邊指派子類別實體 -&gt; Employee e = new Manager(7002,\"Peter\",50000.0,10000.0); 定義：用父型別宣告子型別的實體 如果都只是單純型別，不使用多型，那當宣告陣列的話，就需要宣告父類別、子類別、孫類別等等不同類別的陣列，但若多型只需要宣告父類別的陣列就可以直接用 利用多型 new 一個 instance 時，在調用 method 的時候，會 借過 父類別的 method，因此父類別也要宣告此 method，而子類別該 method 要做 overriding 說明一個 annotation @Override，O 大寫 但這邊每個子類別都要宣告 @Override，其實不夠好。這邊課程有提出，用 abstract 抽象修飾詞。 abstract 三大功用 1.定義規格給子類別，2. 讓多型技術可以找到父類別方法，也可以向下找到子類別 Overriding 的方法，3. 讓錯誤發生在編譯時期傳入物件參考變數與原始資料型態的差異class Test { public static void passByValue(int value) { value = 20; } public static void passByReference(Shirt myshirt) { myshirt.price = 20; } public static void main(String[] args) { // 原始資料型別 int x = 10; passByValue(x); System.out.println(x); // 印出 10 // 物件參考變數 Shirt myshirt = new Shirt(); myshirt.price = 10; passByReference(myshirt); System.out.println(myShirt.price); // 印出 20 }}多型的陣列宣告範例 多型的應用場景範例一，如果都不用多型，要個別宣告陣列存放該型別物件// 宣告 FullTimeEmployee 的陣列FullTimeEmployee[] ftEmpList = new FullTimeEmployee[1];ftEmpList[0] = new FullTimeEmployee(7002,\"peter\",50000.0);// 宣告只能放 Manager 的陣列Manager[] mgEmpList = new Manager[1];mgEmpList[0] = new Manager(7003,\"merry\",50000.0,10000.0);// 宣告只能放 PartTimeEmployee 的陣列Employee[] empList = new PartTimeEmployee[1];empList[0] = new PartTimeEmployee(7004,\"john\",1000.0,8);// 要呼叫方法還要每個陣列都遍歷才行for(int i = 0; i &lt; empList.length ; i++){ empList[i].getSalary();}for(int i = 0; i &lt; ftEmpList.length ; i++){ ftEmpList[i].getSalary();}for(int i = 0; i &lt; mgEmpList.length ; i++){ mgEmpList[i].getSalary();}範例二，用多型，只要宣告一個父類別的陣列，存放各種不同子類別的物件Employee[] empList = [3];empList[0] = new FullTimeEmployee(7002,\"peter\",50000.0);empList[1] = new Manager(7003,\"merry\",50000.0,10000.0);empList[2] = new PartTimeEmployee(7004,\"john\",8000.0,8);for(int i = 0; i &lt; empList.length; i++) { empList[i].getSalary();}" }, { "title": "011_關於 SpringBoot 框架的配置魔術", "url": "/posts/%E9%97%9C%E6%96%BCSpringBoot%E6%A1%86%E6%9E%B6%E7%9A%84%E9%85%8D%E7%BD%AE%E9%AD%94%E8%A1%93/", "categories": "Backend", "tags": "java, springboot", "date": "2022-08-17 16:09:00 +0800", "snippet": "目標了解 Java Springboot 框架在配置過程中，發生了哪些事情，經過哪些流程。參考https://tanzu.vmware.com/content/springone-platform-2017/its-a-kind-of-magic-under-the-covers-of-spring-boot-brian-clozel-st%C3%A9phane-nicollSpringBoot 啟動器https://start.spring.io/ 通常 IDE 也會有相關的快速初始化一個 Springboot 專案的功能，例如 InteliJ IDEA 或 eclipse關於 SpringbootSpringboot 的一個強大特性是它可以自動化配置，而該關鍵要素來自於 convention-over-configuration (約定優於設定)拆解 annotations 在一個 springboot application 下，會在入口看到有一個 annotation 為 @SpringBootApplication 再往下看會看到 3 個 annotations，@SpringbootConfiguration、@ComponentScan 和 @SpringBootAutoConfiguration，關鍵在 @SpringBootAutoConfiguration查看 pom.xml 針對 parent 字段，可以查看其依賴的父項目為 spring-boot-starter-parent 針對 spring-boot-starter-parent 的 pom 檔還可以查看到有 parent 字段，其依賴父項目為 spring-boot-dependencies 最後在看到 spring-boot-dependencies 的 pom 檔發現沒有 parent 字段了，而這個 pom 檔往下拉，會發現 dependencyManagement 字段，在該字段下就是在 spring-boot-dependencies所有依賴的 Jar 從 pom 可以看見 springboot 在 約定優於設定 的部分細節，因為在我們初始化整個專案的過程，它默默的依賴了相關的套件，默默定義的相關的設定並且記錄在 pom 檔內Java 階段學習 https://www.bilibili.com/video/BV12J41137hu? https://www.bilibili.com/video/BV1V4411p7EF? https://www.bilibili.com/video/BV1LJ411z7vY? https://www.bilibili.com/video/BV12J411M7Sj? https://www.bilibili.com/video/BV1NE411Q7Nx? https://www.bilibili.com/video/BV1WE411d7Dv? https://www.bilibili.com/video/BV1aE41167Tu? https://www.bilibili.com/video/BV1PE411i7CV? https://www.bilibili.com/video/BV1jJ411S7xr? Java SE -&gt; Java 多線程 -&gt; Java 網路程式設計 -&gt; Java EE Web -&gt; Spring -&gt; SpringMVC -&gt; SpringBoot -&gt; SpringCloud課程 Note 參考 https://mp.weixin.qq.com/mp/homepage?__biz=Mzg2NTAzMTExNg==&amp;hid=1&amp;sn=3247dca1433a891523d9e4176c90c499" }, { "title": "010_使用 helm 來管理 application on kubernetes", "url": "/posts/%E4%BD%BF%E7%94%A8helm%E5%81%9Akubernetes%E7%9A%84Application%E7%AE%A1%E7%90%86/", "categories": "DevOps", "tags": "helm, kubernetes", "date": "2022-08-17 16:09:00 +0800", "snippet": "目標隨著專案越來越多，管理 kubernetes 內部 deployment、service、ingress、configmaps 物件越來越多。對於多檔切換來切換去的管理也越來越不堪負荷，也害怕自己哪裡改壞了，沒正確上到對應的配置導致部署有問題沒發現。最近開始想要導入 helm 來做在 kubernetes 內的 application 做管理。測試開發 Chart 心得總結 跟 golang template 有很大的關係，裡面語法大都類似 當要利用模板渲染時，要注意 scope，比較要注意的是 with 關鍵字。 條件控制 if-else 和 range 比較常用，range 雷同 foreach 的功能 要注意 template render 後的空格，適時的使用 {{- 和 -}} 絕大部分情況會用 {{- 模板定義會用 define 包起來，並且 helm 建議所有定義都放在 _helpers.tpl 檔案裡 使用 include 或 template 引入模板，兩者差異在於 include 是 function，他可以透過 | 再次做數據處理，而 template 僅是執行複製貼上的動作，所以無法將輸出傳入給另一個 function 做輸入，因此 helm 建議用 include 可以更好的處理縮進問題Chart 基本概念Helm 安裝 resource 的順序https://helm.sh/docs/intro/using_helm/Chart 基本結構mychart/ Chart.yaml values.yaml charts/ templates/ ... templates 目錄存放 template 檔案，helm 在運行 chart 的同時，會將所有 templates 目錄裡面的檔案發送給 template rendering engine(模板渲染引擎) values.yaml 檔案對於 template 非常重要，這個檔案包含在整個 charts 的default values，當執行 helm install 或 helm upgrade 這些 values 會被用來覆寫。 Chart.yaml 包含整個 chart 的描述，可以在 template 裡面訪問 Chart.yaml，而 charts/ 目錄會包含其他 chart，也可稱作為 subcharts初探 templates/ 目錄的檔案 NOTES.txt，一些提示字串，用來幫助安裝 chart 的時候顯示給 user 看的描述。 deployment.yaml，基礎的 manifest，就是 kubernetes 的 deployment 物件。 service.yaml，基礎的 manifest，就是 kubernetes 的 service 物件。 _helpers.tpl，存放可以讓這個 chart 被重用的模板協助器。 template 雖然沒有強制性規定命名規則，但 helm 建議還是用 .yaml 來作為 YAML 檔案的 suffix，且用 .tpl 作為模板協助器檔案的 suffix測試基本渲染 template 的方式先創建 helm charthelm create demo demo 為 chart name 可以隨意取，完成後會依照取的名子生成一個目錄。移除 templates/ 目錄下所有檔案rm -rf demo/templates/*在 templates/ 目錄下新增一個 configmaps.yaml 檔案apiVersion: v1kind: ConfigMapmetadata: name: {{ .Release.Name }}-configmap data: myvalue: \"Hello World\" 這邊的關鍵在 metadata 下面的 name，後面用了一個 {{ .Release.Name }} 。關於 {{ .Release.Name }} 的解讀這邊的定義可以解讀為，從 top namespace 開始找 Release 物件，並從 Release 物件裡找到一個物件叫做 Name 的。 Release 物件是 helm 物件的一種helm 內建的物件 把定義的物件透過 template engine 傳入 template 測試 with 和 range statements 甚至有方法能直接在 template 裡面 new 一個物件，例如用 tuple function 物件可以單純是一個值，或是其它物件或 functions。Release 物件 Release 物件是在 template 中可以訪問的最高級物件 Release 物件用來描述它自己本身，它內部有幾個物件 Release.Name 該 release 的名稱 Release.Namespace 該 namespace，如果 manifest 裡面沒有宣告 Release.Revision 該 release 的 revision 號碼，install 後為 1，往後 upgrade 會往上加，或 rollback 往下減 Values 物件 Values 透過 values.yaml 檔案傳入 template，預設情況下 Values 是空的Chart 物件 是 Chart.yaml 檔案的內容 在 Chart.yaml 檔案內的可用參數可參考 https://helm.sh/docs/topics/charts/#the-chartyaml-fileFiles 物件 用來提供在 charts 裡面訪問所有非特定 (non-special) 的檔案 檔案物件的使用方式，參考 https://helm.sh/docs/chart_template_guide/accessing_files/Capabilities 物件 提供 kubernetes cluster 支援的資訊Template 物件 包含當前被執行的 template 的資訊 補充，在 Go 裡面，大寫字母開頭通常被用來表示 build-in 的物件。是 Go 的命名原則。進一步探討上面提到的 Value 物件 它可以透過多個來源來傳入 chart 該 chart 裡面的 values.yaml 檔案 如果是 subchart，來自 parent chart 的 values.yaml 執行 command 時帶入的 -f 參數的指定 values.yaml 檔案 例如 helm install -f myvalues.yaml ./mychart 執行 command 時代入的 --set 參數指定的方式 例如 helm install --set foo=bar ./mychart 順序優先級 values.yaml 是最先的 如果 subchart 內的 values.yaml 值不存在，調用 parent 的 values.yaml 來覆蓋 而這些 values.yaml 檔可以被 user 定義的 -f 和 --set 參數覆蓋 測試為 --set foo=bar &gt; -f myvalue.yaml &gt; values.yaml延續基礎，在 template 中如何把內容再進一步做轉換變成我們想要用的內容假想一種情況前面我們透過 {{ .Release.Name }} 的方式把 template 字元轉換成我們要的內容，但這種方式為固定一組對應的轉換，但隨著內容越來越複雜，我們會遇到要將內容轉換的同時，對這些內容作”再處理”。以下將使用 .Values 物件展示部分 Case。在 inject 到 template 時，用 quote (“”) 將內容包住apiVersion: v1kind: ConfigMapmetadata: name: {{ .Release.Name }}-configmapdata: myvalue: \"Hello World\" drink: {{ quote .Values.favorite.drink }} food: {{ quote .Values.favorite.food }} 其實 helm template language 跟 go template language 類似default function是非常常使用的 function，該 function 可以指定一個預設的 value 在 template 裡面。例如：drink: {{ .Values.favorite.drink | default \"tea\" | quote }}談談 templates/_helper.tpl 檔案 最主要是設計來讓所有 template 都可以 re-use 的字段 先 define 一個 block 名稱 -&gt; 在 template 裡面透過 template 關鍵字或 include 關鍵字找到 _helper.tpl 內定義的 block 名稱，引入到該 template 裡面具體實踐 先建置一個 _helper.tpl 檔案，並定義 fullname 區塊 新增一個 configmaps template 並定義 include 關鍵字，使其能引用 _helper.tpl 的值_helper.tpl{{/*Create a default fully qualified app name.We truncate at 63 chars because some Kubernetes name fields are limited to this (by the DNS naming spec).If release name contains chart name it will be used as a full name.*/}}{{- define \"fullname\" -}}{{- if .Values.fullnameOverride }}{{- .Values.fullnameOverride | trunc 63 | trimSuffix \"-\" }}{{- else }}{{- $name := default .Chart.Name .Values.nameOverride }}{{- if contains $name .Release.Name }}{{- .Release.Name | trunc 63 | trimSuffix \"-\" }}{{- else }}{{- printf \"%s-%s\" .Release.Name $name | trunc 63 | trimSuffix \"-\" }}{{- end }}{{- end }}{{- end }}configmaps.yamlapiVersion: v1kind: ConfigMapmetadata: name: fair-worm-configmapdata: myvalue: \"Hello World\" drink: {{ .Values.favorite.drink | default (printf \"%s-tea\" (include \"fullname\" .)) }} food: \"PIZZA\"執行 helm 指令查看生成的 object 樣子helm template demo . demo 可以隨意，這個參數所代表的意義是 chart name常用 function 整理Date 相關的 now 取得當前的時間，常用來搭配其他時間 function date 格式化時間 Golang 的 time 套件在 format 時間字串時有自己定義的做法。他不像其他語言用 %D 或 %Y 之類的代碼，而是直接用一個自訂標準時間，它的規律就像計數 12345 那樣。例如宣告以下的 function，我們會得到 UTC+8 的標準 24 小時制當前時間{{ now | date \"2006-01-02 15:04:05 +0800\" }}String 相關的 contains，用來測試字串內有無包含特定的字，返回 true 或 false 範例 contains \"cat\" \"catch\"，返回 true quote 和 squote，把 String 用雙引號(quote)或單引號(squote)包起來 範例 \"hello\" | quote ，返回 \"hello\" indent，會把字串用空格縮排，nindent 跟 indent 一樣，但會在一開始先空一行 範例 indent 4 \"hello\" 返回 \" hello\" replace，取代字串 範例 \"I have a pen\" | replace \" \" \"-\" 返回 \"I-have-a-pen\" 其他參考https://helm.sh/docs/chart_template_guide/function_list/flow control 重點摘要甚麼情況會判斷為 false 直接給定 boolean 為 false 時 當數字型別為 0 時 空字串 \"\" 時 出現 nil 關鍵字時 出現空的 collection 時(無論是 map / slice / tuple / dict / array)排版問題在 template engine 渲染過程，會把 {{ 中間內容 }} 大括號對的內容刪除並且保留其空白，而最後渲染出來就會變成多了空格，文件舉例當我們給定一個這樣的 configmaps.yamlapiVersion: v1kind: ConfigMapmetadata: name: {{ .Release.Name }}-configmapdata: myvalue: \"Hello World\" drink: {{ .Values.favorite.drink | default \"tea\" | quote }} food: {{ .Values.favorite.food | upper | quote }} {{ if eq .Values.favorite.drink \"coffee\" }} mug: \"true\" {{ end }}渲染結果會變成apiVersion: v1kind: ConfigMapmetadata: name: telling-chimp-configmapdata: myvalue: \"Hello World\" drink: \"coffee\" food: \"PIZZA\" mug: \"true\" 可以看到 food 和 mug 之間多了一行空白這時候 helm 提供的作法是去除空白，在大括號後加上 - 符號來告訴 template engine 把空格處理掉，這邊要注意的是，在 helm 裡面，渲染後的換行就等同於空格，因此我們可以改成apiVersion: v1kind: ConfigMapmetadata: name: {{ .Release.Name }}-configmapdata: myvalue: \"Hello World\" drink: {{ .Values.favorite.drink | default \"tea\" | quote }} food: {{ .Values.favorite.food | upper | quote }} {{- if eq .Values.favorite.drink \"coffee\" }} mug: \"true\" {{- end }} 注意，{{- 代表是清除左邊的空格，而 -}} 代表是去除右邊的" }, { "title": "009_Java 課程 Day4", "url": "/posts/Java%E8%AA%B2%E7%A8%8BDay4/", "categories": "Course", "tags": "java", "date": "2022-08-14 09:30:00 +0800", "snippet": "今日進度Method overloading Overloading 相同名稱的 method 傳入不同的參數。(p90)，最典型的例子 System.out.println() Overloading 若找不到對應的參數及型別，會先找最接近的。(p93) Overloading 重點範例 HelloWorld.java 講解 println 到底是誰的 method。解釋 System.out.println() 的由來這邊的呼叫方式是，呼叫 System 類別的 out 變數，而在 System 類別下 out 變數是這樣宣告的。public static final PrintStream out 可以發現 out 的型別是 PrintStream 並且是 static 的變數，所以可以透過 System.out 直接呼叫。而 out 變數是 PrintStream 類別，PrintStream 類別裡面有 println() 方法。因此可以直接呼叫該方法封裝 有四種修飾詞 public protected 預設 private 有提到 JavaBean，POJO封裝過後，會增加 setXX 和 getXX 方法，這樣會讓程式碼變多，但好處是 可以加邏輯來判斷誰能修改，而不用在調用它的地方寫邏輯（Class A 變數不應該在 Class B 方法調用時進行判斷邏輯) 也不用在 main 方法加處理物件 attributes 的邏輯 封裝：用公開的方法去存取私有的變數 this 關鍵字，代表當前物件的統稱 練習 Employee 範例，透過 setXX 與 getXX 方法展示封裝使用流程 (Employee.java,EmployeeTest.java)複習變數的範圍 Variables scope 判斷區域變數，實體變數，靜態變數（類別變數）Constructor 建構子 一個 class 允許多個建構子 建構子沒有回傳值（所以沒有宣告回傳型別） 建構子可以有 Access Control 修飾詞 說明當 variables 變多，建構子的劣處 練習 overloading constructor (EmployeeCons.java) 建構子可以用 this 呼叫其他建構子(EmployeeConsAddr.java) 建構子搭配封裝、Overloading 一起做使用 (Employee2.java,EmployeeTest2.java)陣列 陣列也是放記憶體位址的值 畫圖先畫直的(不管一維陣列還是多維陣列) Java 是可以做到非矩形陣列的(p115) 口訣：橫列 row 直欄 column這邊有一個例子int xx[][] = new int[4][]; // 這編譯可以過，而且寬度是可變的## 補充 - 可變參數 - 從 Java 1.5 開始，傳遞同型別的參數後面 + `...` 就是可變參數- 可變參數要在其他參數後聲明，因此可變參數的宣告要放在最後- 當調用方法的時候，參數傳遞的數量不確定，那麼可以用可變參數接收傳遞進來的參數再做邏輯判斷### 可變參數範例```javaclass Demo { public static void main(String[] args) { Demo myDemo = new Demo(); myDemo.test(\"hello\",\"world\",\"friends\"); // 也可以寫成，類別調用 Demo.test(\"hello2\",\"world2\",\"friends2\"); } public static void test(String... str) { for(int i = 0 ; i &lt; str.length ; i++ ) { System.out.println(str[i]); } }}" }, { "title": "008_Java 課程 Day3", "url": "/posts/Java%E8%AA%B2%E7%A8%8BDay3/", "categories": "Course", "tags": "java", "date": "2022-08-13 09:30:00 +0800", "snippet": "今日進度今日課堂練習https://github.com/atorigin/java-course/tree/master/day3物件參考變數 Object Reference Variables 記憶體空間的概念 物件參考變數裡面放的是記憶體位址的值 物件參考變數有三種給值的方法(用 . 運算子，用封裝 setXXX 方法，用建構子初始化) Java 是 Pass by value 並非 Pass by reference (p63頁) 如果是原始資料型別，他是傳”值”進去變數。如果是物件，則是傳”記憶體位址的值”進去變數。 最好的是第二種，用封裝 setXXX 方法的方式給值String 類別 (p64) Immutable 不可變，以 String 宣告之後，每次修改都不會異動到原記憶體內容的值，使用 String 的方法時，回傳的任何值都會在記憶體開創新空間。 有字串池的概念(String Pool) (練習檔案 day3 : TestString.java) 用 new 的話會創造自己的記憶體空間，而沒有用 new 的宣告則會在 String Pool 先搜尋是否有相同的字串，有則直接使用。 String Pool 是 Java 為了優化效能獨有的 所以在比對 String 時，應該用其提供的 .equals方法，而不該用 ==。因為 == 是比對記憶體位址。String 類別常用的 method charAt(int index) -&gt; char (練習檔案 day3 : StringCharAtMethod.java) length() -&gt; int (練習檔案 day3 : StringLengthMethod.java) isEmpty() -&gt; boolean substring(int beginindex, int endindex) -&gt; String (StringSubstringMethod.java) compareTo(String anotherString) -&gt; int (StringCompareToMethod.java) 這邊有帶到讀 API 文件時，要注意該方法對於 Java 版本是否有支援，例如 isEmpty() 方法是 Java6 才有支援補充 補充 trim() 方法，去除前後空白 練習將一個字串 Apple.gif 分別抓出 Apple 和 gif 字段印出 (CourseHandsOn.java) 說明 split 方法，他所傳入的是正則表達式。 split(String regex) -&gt; String[] (StringSplitMethod.java)條件判斷 if-else 大括號內若只有一行程式碼，則大括號可以省略。 (TestIfElseAnd.java) switch-case 如果沒有 break 的特性，後面還是會執行到。 Java7 以前，switch-case 只能用字元或整數做判斷。Java7 之後開始 switch-case 可以用字串做判斷迴圈 總共三種類型，for，while和do-while 迴圈的大括號內若只有一行程式碼，則大括號可以省略。 以 99 乘法表練習二維陣列概念，以二維陣列概念理解 Database Column 和 Row 概念今日補充 - 額外帶到的內容 Method 傳入參數和回傳值練習 導讀 Java API 文件，如何閱讀 API https://docs.oracle.com/javase/8/docs/api/" }, { "title": "007_Java 課程 Day2", "url": "/posts/Java%E8%AA%B2%E7%A8%8BDay2/", "categories": "Course", "tags": "java", "date": "2022-08-07 09:30:00 +0800", "snippet": "前言 變數型別 變數宣告 命名規則 Java Keyword,Reserved word(關鍵字,保留字)老師特別提 charpublic char colorCode = 'U'; 一定要用單引號，且僅能放一個字元資料型別 補充 - double 和 float 型別有誤差public class doubleFloat { public static void main(String[] args) { float fValue = 0.0f; for(int i = 0 ; i &lt; 10 ; i++ ) { fValue += 0.1; System.out.println(fValue); } }}// 結果0.10.20.30.40.50.60.700000050.80000010.90000011.0000001 以日期範例舉例 long type 的重要性 long long2 = du.getTime() + 30*24*60*60*1000L;java.sql.Date ds2 = new java.sql.Date(long2);System.out.println(\"java.sql.Date() = \"+ ds2); 以 IO 範例舉例 byte 的重要性 以 int var_a = ‘A’ 展示電腦看到字元其實是數字，所以以下編譯是會過的，也可執行，但可讀性差。 額外說明 unicode (i18n 國際化應用) public class TestOnly_But02{\tpublic static void main(String args[])\t{\t\t\t char ch1 = 'A'; \t char ch2 = 65; \t char ch3 = '\\u0041'; \t System.out.println(ch1); //A\t System.out.println(ch2); //A\t System.out.println(ch3); //A\t \t int i = 65+1; \t int j = 'A'+1; \t int k = '\\u0041'+1;\t System.out.println(i); //66\t System.out.println(j); //66\t System.out.println(k); //66\t \t char l = 65+1; \t char m = 'A'+1; \t char n = '\\u0041'+1;\t System.out.println(l); //B\t System.out.println(m); //B\t System.out.println(n); //B\t System.out.println(65+1); //66\t System.out.println('A'+1); //66\t System.out.println('\\u0041'+1); //66 \t // unicode 搭配國際化的 i18n 說明重要性\t System.out.println('\\u3105'); //ㄅ\t System.out.println('\\u3106'); //ㄆ\t System.out.println((char)('\\u3105'+1)); //ㄆ\t \t String s = \"Hello \\u4e16\\u754c\\u4f60\\u597d !\"; //Hello 世界你好 !\t System.out.println(s);\t \t}} 用 loop 宣告時，將 i 宣告為 char type，第 2 個 block 會打印空白(因為查 ASCII 字元表前面都是空白)public class TestOnly_But03{\tpublic static void main(String args[])\t{System.out.println(\"----------------1\");\t \t for (char i=65 ; i&gt;=65&amp;i&lt;=90 ; i++) {\t System.out.println(i);\t }\t System.out.println(\"----------------2\"); \t \t for (char i=1;i&lt;=10;i++) {\t\t System.out.println(i);\t } } 講解浮點數及 double / float 誤差說明，以範例展示 資料型別位階高低有差異，位階小的不能接大的型別(double &gt; float &gt; long &gt; int &gt; short &gt; byte) float a = 0.0; // 編譯不會過，預設沒給會是 D(double)double b = 0.0F; // 編譯可以過double c = 0.0; // 編譯可以過 Java 7 以後宣告 int 可以用 _ 來增加可讀性，結果會一樣。int a = 123456789;System.out.println(a); // 123456789int b = 123_456_789;System.out.println(a); // 123456789，同上面跳脫字元 反斜線 \\ 較常用 \\\" \\n \\\\ \\t 變數命名規則 可以用 A-Z，a-z，0-9 還有另外領個符號 $ 和 _。其他都不能拿來當作變數名稱 第一個字不能為 0-9 case-sensitiveJava 關鍵字和保留字 null 也是一種值 public 修飾詞在 method 是沒意義的變數的種類與有效範圍 區域變數，又稱 automatic variable 或 temporary variable 或 stack variable(以記憶體位置角度來稱呼) 在方法(method)內的變數，方法執行結束會被 Java GC 回收。 實體變數，又稱成員變數 member variable 或 attribute variable(屬性變數) 在執行時期的變數 類別變數，又稱 static variable 類別載入時期的變數，就是用 static 修飾字的。 當用 static 修飾字時，呼叫的時候不要用生成的物件呼叫，要用類別呼叫。 實體變數與類別變數在宣告沒給初始值，Java 會給預設值，例如 int 型別會給 0，而物件參考變數則會給 null 變數存活時間：類別變數 &gt; 實體變數 &gt; 區域變數static 關鍵字 - (當日重點)有加 static 與沒加 static 在記憶體中的差異 如果加 static，實際上變數所參考的記憶體位址為同一個 address (他會在 heap memory 的某一個 address)，就代表後面的所有異動都會影響到先前參照該記憶體位址宣告的變數。 如果不加 static，則實際上是指向 stack memory 的 address，而由於每個變數宣告都會在 stack 劃一塊區域，因此即使後面如何做修改，也都僅僅是改到自己劃的區塊的 address 裡面的值，不會影響其它宣告的變數。Item.javapublic class Item { public static int price1 = 100; public int price2 = 200;}StaticVarDemo.java// 使用 Item Class 生成物件，測試 static 變數與非 static 變數差異public class StaticVarDemo { public static void main(String[] args) { // 生成兩個商品物件，每個 item 都在一開始是 price1 = 100，price2 = 200 Item item1 = new Item(); Item item2 = new Item(); // static 的變數 - 修改 item1 的 price1 為 150 item1.price1 = 150; System.out.println(item1.price1); // 打印 item2 的 price1，會發現連 item2 都被改變了 System.out.println(item2.price1); // 非 static 的變數 - 修改 item1 的 price2 為 250 item1.price2 = 250; System.out.println(item1.price2); // 打印 item2 的 price2，會發現沒有變 System.out.println(item2.price2); // 以上可知，item1 與 item2 的 price1 屬性其實是指向記憶體的同一個 address }}關於 stack area memory 和 heap area memory 參考 https://www.tutorialspoint.com/difference-between-stack-and-heap-memory-in-java 參考 https://www.digitalocean.com/community/tutorials/java-heap-space-vs-stack-memory JVM 將記憶體分成兩個部分，一個是 stack，另一個是 heap stack 主要存放 method 執行的順序和 local variables，stack 採 LIFO 的方式存儲 heap 則是採動態分配(或解除分配)記憶體區塊，記憶體被分配到 heap 裡面會存活到兩個事件發生時才會收回 Program terminated 程式結束 Memory free 記憶體釋放 (應該是 GC) -&gt; 在網路上有看到一段 Garbage Collection runs on the heap memory to free the memory used by objects that don’t have any reference 被分配到 stack 的記憶體存活至 function return 為止 以大小來看，stack 對記憶體的使用量會遠小於 heap 以 -XSS 參數調整 stack 大小，以 -Xms 和 -Xmx 界定 heap 空間最小值及最大值 關於 heap 與 stack 的比較進制轉換 - 略 2 進制 10 進制 16 進制 這邊有開編譯完的 .class file 展示 bytecode 裡面數值最多到 F (因為 16 進制)運算子 算術運算子 遞增遞減運算子 指定運算子 關係運算子 條件運算子 位元運算子 移位運算子 三元運算子 位元運算子與移位運算子 - 參考用要注意運算子優先級 ++ 和 -- 最先執行 = 最後執行" }, { "title": "006_Java 課程 Day1", "url": "/posts/Java%E8%AA%B2%E7%A8%8BDay1/", "categories": "Course", "tags": "java", "date": "2022-08-06 09:30:00 +0800", "snippet": " 環境安裝的內容就先略過了前言 說明 Java SE / Java EE / Java ME 差異 說明 Java 根基知識重要性 導覽 Part1 幾項重點名詞 JDK JVM JRE API BytecodeJRE 的三種階段 編譯時期 (javac) 載入時期(安全性 - 提到 static 關鍵字) 執行時期Java 環境建議重點配置的環境變數課程練習摘要 main 方法是程式入口 在宣告 method 中的 void 代表該 method 沒有 return 變數代表在記憶體中的一個位址 char type 要用單引號 '' class 有兩種成員，一為變數、二為方法 另外有一種特殊方法為 constructor (建構子)課堂練習的程式碼HelloWorld.javapublic class HelloWorld { public static void main (String[] args) { System.out.println(\"HelloWorld!\"); }}Shirt.javapublic class Shirt { public int shirtID = 0; public String description = \"-description required-\"; public char colorCode = 'U'; public double price = 0.0; public int quantityInStock = 0; public void displayShirtInformation() { System.out.println(\"Shirt ID: \" + shirtID); System.out.println(\"Shirt description:\" + description); System.out.println(\"Color Code: \" + colorCode); System.out.println(\"Shirt price: \" + price); System.out.println(\"Quantity in stock: \" + quantityInStock); System.out.println(\"----------------------------------------\"); }}ShirtTest.java (當日重點)public class ShirtTest { public static void main (String[] args) { Shirt myShirt; myShirt = new Shirt(); // myShirt.displayShirtInformation(); // 生成第一件衣服 Shirt s1; s1 = new Shirt(); s1.shirtID = 1; s1.price = 100; s1.colorCode = 'R'; s1.displayShirtInformation(); // 生成第二件衣服 Shirt s2; s2 = new Shirt(); s2.shirtID = 2; s2.price = 200; s2.colorCode = 'G'; s2.displayShirtInformation(); } }程式入口點 - main 方法的定義 public 與 static 兩個修飾詞可以調換位置 main 方法的參數 String[] args 也可以寫成 String args[]。還可以空一格 String args []，有點醜而已。 args 變數名稱可以隨意，但傳入字串陣列 String[] 是必要的。 main 方法兩個修飾詞 public static 必須都要存在 main 方法絕對不能 return value，所以一定 return type 一定是 void練習手動打 main (為了把 main 的宣告背起來)課程教材 ch3-2public class QuotationTest2 { public static void main(String[] args) { Quotation myQuotation; // 生成 Quotation instance myQuotation = new Quotation(); myQuotation.display(); }}改歡迎 textpublic class QuotationTest2 { public static void main(String[] args) { Quotation myQuotation; myQuotation = new Quotation(); myQuotation.quote = \"Welcome to Tibame\"; myQuotation.display(); }}" }, { "title": "005_啟用 Blog 的 GA 紀錄瀏覽數功能", "url": "/posts/%E5%95%9F%E7%94%A8blog%E7%9A%84ga%E7%B4%80%E9%8C%84%E7%80%8F%E8%A6%BD%E6%95%B8%E5%8A%9F%E8%83%BD/", "categories": "Blog", "tags": "google-analytics, gcp, github-pages", "date": "2022-08-01 17:04:06 +0800", "snippet": " 因為 GA 版本問題，這種作法只能用到 2023 的 7 月份目標既然都自己建 blog 了，當然也要關注一下有沒有人來瀏覽看看，所以就直接參考官網提供的方式，啟用 page views 功能來查看文章瀏覽數。參考資料 https://chirpy.cotes.page/posts/enable-google-pv/設定流程總覽 透過 https://analytics.google.com/ 設定 GA 帳號和 property 前往 GCP 介面設定 Google App Engine 設定 GA superProxy (透過 google cloud shell) 設定 Blog 把顯示文章瀏覽數功能開啟設定流程重點截圖到 https://analytics.google.com 點開始測量，填入帳號名稱(自己隨便填)，然後帳戶資料共用設定採預設就好設定資源名稱 設定資源時，要把進階選項的通用 Analytics 功能打開(下面的流程照著做才能成功)其他資訊(這部分應該可以隨意填)設定 GA 資料來源複製 Measurement ID(評估ID) 到自己 repo 的 _config.yml，設定 google_analytics 的 id 字段，然後 git push 一次大概 push 後過一段時間(官網是說 5 min)，可以在 GA 的 Dashboard 上面看到部落格的 traffic 資訊到 GCP https://console.cloud.google.com/appengine 建立 Google App Engine (這邊官網有說費用在 free-tier 之下，但僅限用於官網此篇設定)。這邊如果沒啟用 billing 的 GCP Account 要先啟用到 API &amp; Services 的頁面啟用 Google Analytics APIs 的功能先部署一版 app engine 會得到一個 app engine 的 public url (這個部署上去的服務是 GA superProxy) ps:應該是很舊的東西了，移除 src/app.yaml 的最上面兩行 ; 這邊可以用 cloud shell 操作，注意路徑要在 src 底下到 GCP 的 API &amp; Services 介面，左邊導覽列點選 Oauth consent screen 創建一個 external type 的。以下資訊要填 email 的都填自己的 GCP 用的 gmail 即可 這個 url 會對該 email 做驗證確認，只有有權限的人才能操作 superProxy 介面，上面要填 app domain 的地方要換成自己部署到 app engine 後得到的 url左邊導覽列點 Credentials 創建一個 OAuth Client IDs 的 credentials，然後取得 client id 和 client secret回到 cloud shell editor，編輯一版 src/config.py 如圖設定，將相關設定都填入。然後再佈署一版 一樣到 src 目錄下執行 gcloud app deploy 舊好進入 superProxy 的頁面，基本上就是 app engine url + /admin 路徑，大概會長這樣 https://blog-enable-page-views.de.r.appspot.com/admin，進去後先創建 user(email)，然後再用 email 去驗證這個 superProxy 上圖顯示的 Revoke Access 如果沒驗證過應該會是 Authorize Access。(這邊記得要先 Manage Users 把驗證用的 email 填進去再點 Authorize Access)。 ps: 我這邊統一都用上面那個 GCP 的 gmail 做測試(沒測過不同 mail 會不會有問題)驗證流程，會出現請求你的 google 資料創建 Query，用 UA 工具把 Query 生成的 URI 貼近 Query 的 Encoded URI for the query text field 裡面 UA 工具，要先用創建 GA 的 gmail 帳號登入創建完成後，取得 public endpoint。enable 和 start scheduling回到部落格的目錄設定 _config.yml 把 ga 的 proxy_endpoint 設定好並重新 git push 一次最後就能在 blog 看到閱覽數，而且在 GA 的介面也能觀察使用者了!!其它故障排除 可能會遇到 gcr 沒有啟用的問題，或遇到其它 API 沒有啟用的問題 (我這邊有遇到 cloud build API 沒啟用但其實有啟用) 後來就正常了，我估計可能是因為我在做這個的時候，新開了一個 GCP 的 Project，有些環境初始化還沒完成。(如有遇到怪問題的，建議可以用預設的 GCP Project 做)" }, { "title": "004_EKS 部署 ExternalDNS 整合 Cloudflare", "url": "/posts/EKS%E9%83%A8%E7%BD%B2ExternalDNS%E6%95%B4%E5%90%88Cloudflare/", "categories": "DevOps", "tags": "cloudflare, kubernetes", "date": "2022-07-27 06:24:00 +0800", "snippet": "起源在部署、上線一個新專案時，通常我們會先寫好該專案的一些 yaml 配置檔，包含 deployment / service / ingress / configmap 等等。將服務的一系列會用的的資源定義好，最後 apply 到 cluster 裡面。而最後一步，我們通常需要依據定義的 ingress 裡面的 host 來將 DNS Record 建立在 DNS Provider 上，有可能是在 Cloudflare / AWS Route53 / Godaddy 之類的，而每次一個新專案要上線都必需要這麼做。這個設定的工作就好像一個固定形式的 SOP，久而久之就開始感到無趣。身為一個 devops 工程師，這種 SOP 的工作當然能希望自動(智慧)一點，因此就開始調研怎麼樣能夠達成，也就有了此篇關於 External DNS 的文件紀錄。環境基於 eks，並在 eks 裝有 ingress-nginx。採用 Cloudflare 作為 DNS Provider。 當部署上去之後，最終 DNS Provider 會在 DNS Record 幫我們創建一筆 CNAME Record 並指向我在架構上的 AWS NLB FQDN 位址關於 External DNS 工具簡單來說就是透過部署 kubernetes 的 service 或 ingress 資源時，同時在 DNS Provider (此篇是採用 Cloudflare) 上面創建 DNS Record 來讓 DNS 能指向 EKS 的位置。External DNS 透過 DNS 的 txt type 來辨識它所管理的 records。(這點會在部署之後，創建 record 的同時也會建立一筆 txt type 的 record)準備 Cloudflare 的 API_TOKEN (Token 的權限要對全部的 Zone 有 Read 權限、對 DNS 有 Edit 的權限) Cloudflare 的 Zone_id (限制在某個 Zone)流程 創建 cloudflare 對應權限的 API token 調整 external-dns 的參數 透過 helm 部署 external-dns 部署一個範例服務 deployment /service / ingress 並測試可否透過 DNS 訪問到該服務 驗證 (查看 cloudflare 的 dns record / 查看 external-dns 的 pod logs)創建 cloudflare 對應權限的 API Token調整 external-dns 參數，這邊是用 helm chart(版本為 1.10.1)，故為調整 values.yaml# 主要調整一下幾個字段## 注入 cloudflare 對應權限的 tokenenv: - name: CF_API_TOKEN value: \"{剛剛創建的 cloudflare api token}\"## 僅 ingress 來源就好sources: - ingress## 指定 cloudflare 這個 DNS provider (預設是 aws)provider: cloudflare## 可選 - 固定 service account 的名稱serviceAccount: create: true annotations: {} name: \"external-dns\"## 可選 - 我這邊有控制 affinity 所以有特別調整 (一般情況下可不用調整)affinity: nodeAffinity: requiredDuringSchedulingIgnoredDuringExecution: nodeSelectorTerms: - matchExpressions: - key: eks.amazonaws.com/capacityType operator: In values: - ON_DEMAND## 控制僅有指定的 domain - 把 example.com 改成自己的domainFilters: - \"example.com\"## 控制 dns 生命週期的 policy - 一般情況下應該用 upsert-only 避免意外刪除 dns reocrd。## 但若是測試環境用，可用 sync (這樣 dns 紀錄才不會留一堆已經沒再用的 dns record 在上面)policy: upsert-only## 設定建立 txt 規則## txtOwnerId = 自定義的唯一 id，如果有多個 kubernetes cluster，則每個 cluster 應有自己的一個唯一 idregistry: txttxtOwnerId: \"8jLp4X1xOY\" txtPrefix: \"test\"txtSuffix: \"\"## 設定限制在以下的 zone-idextraArgs: - --zone-id-filter={自己的 zone id}helm 部署 helm install -n external-dns --create-namespace -f values.yaml external-dns . 部署 sample-app 並驗證 DNS Records補充 - 在 ingress 上透過 annotations external-dns.alpha.kubernetes.io/hostname: sample.example.com (example.com 要換成自己的 domain) 來宣告 CNAME Record 的 Name。最終我用來測試用的 sample-app.ymlapiVersion: networking.k8s.io/v1kind: Ingressmetadata: name: sample-app annotations: kubernetes.io/ingress.class: nginx external-dns.alpha.kubernetes.io/hostname: sample.example.com external-dns.alpha.kubernetes.io/ttl: \"120\"spec: rules: - host: sample.example.com http: paths: - path: / backend: service: name: sample-app port: number: 80 pathType: Prefix---apiVersion: v1kind: Servicemetadata: name: sample-appspec: ports: - port: 80 targetPort: 80 selector: app: sample-app---apiVersion: apps/v1kind: Deploymentmetadata: name: sample-appspec: selector: matchLabels: app: sample-app template: metadata: labels: app: sample-app spec: containers: - image: nginx name: nginx ports: - containerPort: 80參考文件 參考 https://github.com/kubernetes-sigs/external-dns/blob/master/docs/tutorials/cloudflare.md 參考 https://github.com/kubernetes-sigs/external-dns/blob/master/docs/tutorials/nginx-ingress.md 常見問題 https://github.com/kubernetes-sigs/external-dns/blob/master/docs/faq.md" }, { "title": "003_AWS 之 EKS 概念探索", "url": "/posts/AWS%E4%B9%8BEKS%E6%A6%82%E5%BF%B5%E6%8E%A2%E7%B4%A2/", "categories": "Cloud", "tags": "aws, kubernetes", "date": "2022-07-20 16:12:00 +0800", "snippet": "起源在想要進一步透過 terraform 配置 AWS EKS 叢集的相關設定時，對於在使用場景和部分名詞定義上的觀念有模糊不清且對其具體影響也不了解，故留下此篇文章來加強自己對於 EKS 這個服務的功能更進一步的了解並在往後合適的時機能夠加以應用。關於 node 的種類及其差異總的來說，node 種類分為三種。分別是 self-managed、managed、fargate。而參考過各種資料後，自己理解是「差別在於對 kubernetes 的 control plane 控制權(又或是控制的程度)」。AWS 具體的差異比對 https://docs.aws.amazon.com/zh_tw/eks/latest/userguide/eks-compute.html self-managed : 對於 control plane 有最大的控制，基本上對於 AWS 來說，AWS 認為採用此種類屬於用戶自己管理整個 kubernetes，因為 AWS 並不會干涉用戶創建的任何資源和方式。 managed : 對於 control plane 有一定程度的干涉，並且因為有干涉所以對於部署方式及配置有一定程度的限制。但也因為如此，所以 AWS 把這種節點的 ec2 instance 幫忙管理，也會在更新時遵循用戶的配置將 instance 和 pod 做控管。 fargate : 基本上對用戶來說就是看不到 instance，因為這種模式需要直接定義一個稱為 「fargate profile」的設定檔，只要遵循該設定啟動的 pods，都會用 fargate 的形式部署，與前面兩種最大的差異是它是按 vCPU/硬碟 收費的。並且因為用戶只能管 pods，所以滿多限制條件。但好處是可以最大程度的做到資源利用。(因為無 instance 所以又稱為 serverless)小結 基本上 managed 和 self-managed 都是一樣的費用，它是按 instance 資源的收費標準。所以機器規格多大、用多少硬碟等等的就直接是這兩種的費用。 但因為兩者之間對於 control plane 還是有些許差異，所以目前讀起來感受的最大差異應該是在「如果要用 dedicated host(專用主機)」來部署 EKS，則就必須要用 self-managed 的方式。managed 不提供 dedicated host 部署。 另外像是 managed 也不提供 windows container 和 用 local zone 部署，但不知道未來有沒有機會開放。關於 AWS EKS 的 Pods 限制 AWS EKS 在預設情況下，對於 Pods 部署的數量是有限制的，公式為 ENI * (可用私有IP數量 - 1) + 2。 而每個 instance type 能夠用的 ENI 數量和可用私有 IP 數量限制可以參考 https://docs.aws.amazon.com/zh_tw/AWSEC2/latest/UserGuide/using-eni.html#AvailableIpPerENI 舉例來說一台 t3a.large 最多可以部署的 pods 總數量為 「3 * (12-1) + 2」 = 35關於 EKS 的 Addons (附加元件)因為 terraform 的範例有段配置 addons 的相關設定，故自己往下瞭解。發現 AWS EKS 在自己初始化的時候就會安裝基本的 addons 來確保 cluster 在建置完成後就可以使用基本功能，而這些 addons 是基於 AWS Cloud 的配置，故部分 addons 功能是必要的。參考 addons 說明 https://docs.aws.amazon.com/zh_tw/eks/latest/userguide/eks-add-ons.html像是 VPC CNI / CoreDNS / kube-proxy 這三個在用 EKS 搭建的時候就會自己安裝。 VPC CNI : 讓 kubernetes 內的 pod 可以直接與 VPC 上的 IP 一樣 CoreDNS : 提供 kubernetes 內的 pod 做 DNS 解析 kube-proxy : 會維護每個 Amazon EC2 節點上的網路規則。它使網路能與您的 Pod 進行通訊。 以上情況是 managed / self-managed 的情況，若用 Fargate 情況會不太一樣關於 EKS 的 auto scale 設定機制要做到 EKS 自動擴展，主要有兩種做法。一種是透過安裝 Kubernetes Cluster Autoscaler，而另一種較新，它採用一個開源專案 Karpenter。參考 https://docs.aws.amazon.com/zh_tw/eks/latest/userguide/autoscaling.html#ca-deployment-considerations關於 EKS Cluster OIDC Provider因為要做 Cluster Autoscaler(CA) 功能之前，前置條件必須要讓 cluster 有 OIDC Provider，如果沒有就無法用 CA。參考 - 先決條件 https://docs.aws.amazon.com/zh_tw/eks/latest/userguide/autoscaling.html創建方式可以參考 https://docs.aws.amazon.com/zh_tw/eks/latest/userguide/enable-iam-roles-for-service-accounts.html主要流程為 先到 eks 頁面複製 eks cluster 資訊裡面的 oidc provider url 到 iam 介面的 identity provider 頁面新增一個 provider provider type (供應商類型) : open id connect provider url (供應商 URL) : 剛剛複製的 url audience (對象) : “sts.amazonaws.com”頁面示意圖關於 Cluster Autoscaler 基本概念 控制 scale-in or scale-out : 會根據 --scan-interval 來控制掃描檢查工作負載的時間 可以透過標籤 cluster-autoscaler.kubernetes.io/safe-to-evict=false 來避免重要的工作負載 (pod) 因為 scale-in 移除 node 造成的工作中斷 建議配置使用 “少” node_groups，多 instances in node_groups 來搭配 cluster-autoscaler 透過 irsa 搭配 cluster-autoscaler 的 discovery 來達到控制 aws 的 auto scaling groups 的操作(新增節點或刪除節點)設定 Cluster Autoscaler 的原則基本條件 要先有上面提到的 Cluster OIDC Provider - 這邊用 terraform 創建的 eks node group，所以可以直接用參數 enable 要讓創建出來的 node 都有特定標籤，才能夠自動發現這些 node 要有 IAM 權限可以更新 autoscaling group 的相對設定值。(這邊有兩種方法) 一種是直接給 autoscaling 創建出來的 instance 賦予該權限 =&gt; IAM Role for EC2 instance 另一種是給 cluster-autoscaler 的 pod 的 service account 有 iam role 的權限 =&gt; 透過 IRSA IAM Role for Service account 參考 Auto-Discovery Setup 章節 https://github.com/kubernetes/autoscaler/tree/master/cluster-autoscaler/cloudprovider/aws 每個 ASG 應該要由提供相同 capacity 的 instance type 組成，例如 xlarge 系列 m5a.xlarge/m4.xlarge/m5.xlarge/m5d.xlarge，因為它們都提供 4vCPUs 和 16GiB 的 RAM流程大綱 建立一個 IAM Role，這個 Role 會給 cluster Autoscaler 的 pod 中 service account 針對 aws 的 auto scaling 相對應的權限，讓這個 pod 可以操作 aws 的 auto scaling 部署 Cluster Autoscaler 到 EKS 裡面，這邊會設定對應的 IAM Role arn 給 service account，因為要讓 service account 跟 iam role 做關聯 (這邊就是 IRSA 功能) 查看 Cluster Autoscaler 是否正常 running設定截圖建立 Policy建立 Role 要 attach 剛剛創建的 Policy修改 Role 的 Trust Relationships用 helm charts 部署 cluster-autoscaler 時，要針對 rbac 設定針對整個 charts value 作一些參數調整查看 cluster-autoscaler Pod 相關訊息 補充 關於部署 CA 的考量 (CA 最佳建議)，分為 3 個方向 擴展考量 效能考量 成本效益及可用性 設定 node group 時，在每個 AZ 設定一組，啟用 --balance-similar-node-groups 功能。若是只有一個 node group，則要設定跨多個 AZ。 在 scaling group 內的每個 node 都具備相同的配置，包含 label、taints、resources 原則上配置盡量用少量的 node group。然後在 node group 裡面的 node(instance) 數量可以配置多一點。(若設定相反，則可能造成 scale 一些問題，官網沒明說那些問題) 評估後續 scale 的 instance type -&gt; 若大於一開始設定的 type，則有可能造成資源浪費。但若小於一開始設定的 type，則可能造成 pods 在 schedule 的時候因為資源不夠造成無法運行 盡量用 managed node group，不要用 self-managed 要避免在 scale-down 某些 node 時候，有些重要的 pods 被中斷造成工作中斷且重新來過，例如執行機器學習，大數據分析的工作 pods 之類的。 要避免這類事情發生，請確保在這些重要的 pods 上增加 label cluster-autoscaler.kubernetes.io/safe-to-evict=false 讓 CA 可以辨識的到。當這些 node 上有運行這個標籤的 pod 則該 node 就不會被 scale-down 參考資料曾經參考此影片說明其 node 種類差異關於 Pods 聯網說明 - 在 VPC CNI 的閱讀中有提到 pods 限制的問題關於 Cluster Autoscaler 的 FAQ" }, { "title": "002_利用 terraform 管理 cloudflare DNS Record", "url": "/posts/%E5%88%A9%E7%94%A8-terraform-%E7%AE%A1%E7%90%86-cloudflare-dns/", "categories": "DevOps", "tags": "terraform, cloudflare", "date": "2022-07-18 15:46:31 +0800", "snippet": "目標配置 terraform 來管理特定 cloudflare 的 zone 之 dns record 規則。參考文件設定 cloudflare 的 provider 說明https://registry.terraform.io/providers/cloudflare/cloudflare/latest/docs配置使用說明 terraform 要 &gt;= 1.2.0, &lt; 1.3.0 cloudflare provider 要 &gt;= 3.18.0tf 檔案配置provider.tfterraform { required_providers { cloudflare = { source = \"cloudflare/cloudflare\" version = \"3.18\" } }}provider \"cloudflare\" { api_token = var.cloudflare_api_token}variables.tfvariable \"cloudflare_api_token\" { type = string sensitive = true description = \"The Cloudflare API token.\"}variable \"cloudflare_zone_id\" { default = \"&lt;zone_id&gt;\"}main.tfresource \"cloudflare_record\" \"blog\" { zone_id = var.cloudflare_zone_id name = \"blog\" value = \"atorigin.github.io\" type = \"CNAME\" ttl = 3600}流程 新增 tf 檔案配置 建立 cloudflare API token terraform 專案初始化 terraform plan 試跑查看部署結果 terraform apply 執行真實部署步驟說明新建 tf 檔創建 Cloudflare 的 API Token (用於 terraform)注意 variables.tf 的 zone_id 需參考執行 terraform 初始化、檢驗及部署terraform initterraform planterraform apply驗證結果" }, { "title": "001_我製作的第一篇基於 Jekyll Chripy 主題的文章", "url": "/posts/%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8Jekyll%E8%A3%BD%E4%BD%9CBlog/", "categories": "Blog", "tags": "github-pages", "date": "2022-07-16 20:48:00 +0800", "snippet": " 這是一篇關於我用 Jekyll 的主題 Chripy 製作的第一篇文章。希望透過這篇文章能夠展示 post 撰寫發布的基本功能。修改 favicons 的相關圖檔 先找到要用來做 favicons 的圖片，並利用 製作 favicons 相關圖檔 這個網站生成所需的相關檔案 a. 上傳圖檔 b. 移動到下方點擊 (Generate your Favicons and HTML code) c. 在頁面找到 (Download your package)，點擊旁邊的 Favicon package 下載。 在資料夾內找到 assets/img/favicons 目錄，如果該目錄不存在，則創建此路徑 將剛剛下載 favicon package 解壓縮，將裡面的 .ico 和 .png 檔案複製到 assets/img/favicons 目錄下完成後，可以看見 favicon 已被換成自己設定的圖檔關於 icon 的套件這個 chirpy 主題會引入 submodule fontawesome-free，路徑會在 assets/lib。 每當 build 的時候，這些 css 和 js 檔就會應用在生成 blog site 的網站做使用感想基本上在使用 Jekyll 做為自己的 blog 建置的時候，樣式規則都遵循一套原則，可以參考 Jekyll 套件。而如果要調整一些設定時，就要遵循 Jekyll 的 Content 配置方式。Jekyll 文件 要客製化一些功能比較難，畢竟規則是固定的。自己測試過要增加一個 sidebar 的 custom tab，起初以為在 _tabs 增加一個 title.md 檔案就可以了，但卻不知道要如何讓他 url 指到對應的目錄。關於 Jekyll compose 工具用來節省一些寫文件時的準備時間。jekyll-compose Github 專案可以透過這個工具建立 page / post 等等。設定 jekyll compose 工具，以該工具新增頁面與新增 post 做測試 先設定 Gemfile 安裝該工具 gem 'jekyll-compose', group: [:jekyll_plugins] 安裝 bundle 只用指令生成一個新的 post bundle exec jekyll post '我的POST' --timestamp-format \"%Y-%m-%d %H:%M:%S %z\" 查看 _posts 目錄下面會多一個 .md 就是剛剛生成的新的 post 文件檔，他會幫忙自動生成上面的 Front Matter 字段補充 - 關於文件 md 的 code block 支援的 language 清單https://github.com/rouge-ruby/rouge/blob/master/docs/Languages.md相關 issue 討論https://github.com/cotes2020/jekyll-theme-chirpy/issues/623" } ]
